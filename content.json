{"meta":{"title":"Hexo","subtitle":"","description":"信号处理，软件开发，博客","author":"LCG","url":"https://www.liuchanggeng.xyz","root":"/"},"pages":[{"title":"书单","date":"2020-11-15T08:55:51.753Z","updated":"2020-11-15T08:55:51.753Z","comments":false,"path":"books/index.html","permalink":"https://www.liuchanggeng.xyz/books/index.html","excerpt":"","text":""},{"title":"404 Not Found：该页无法显示","date":"2020-11-15T09:06:52.615Z","updated":"2020-11-15T08:55:51.828Z","comments":false,"path":"/404.html","permalink":"https://www.liuchanggeng.xyz/404.html","excerpt":"","text":""},{"title":"分类","date":"2020-11-15T08:55:51.622Z","updated":"2020-11-15T08:55:51.622Z","comments":false,"path":"categories/index.html","permalink":"https://www.liuchanggeng.xyz/categories/index.html","excerpt":"","text":""},{"title":"标签","date":"2020-11-15T12:34:13.770Z","updated":"2020-11-15T12:34:13.770Z","comments":false,"path":"tags/index.html","permalink":"https://www.liuchanggeng.xyz/tags/index.html","excerpt":"","text":""},{"title":"友情链接","date":"2020-11-15T08:55:51.763Z","updated":"2020-11-15T08:55:51.763Z","comments":true,"path":"links/index.html","permalink":"https://www.liuchanggeng.xyz/links/index.html","excerpt":"","text":""},{"title":"关于","date":"2020-11-16T08:25:54.279Z","updated":"2020-11-16T08:25:54.279Z","comments":false,"path":"about/index.html","permalink":"https://www.liuchanggeng.xyz/about/index.html","excerpt":"","text":"个人详细介绍 QQ:2639350497 本科：哈尔滨工程大学 通信工程 硕士：电子科技大学 电子与通信工程"},{"title":"Repositories","date":"2020-11-15T08:55:51.839Z","updated":"2020-11-15T08:55:51.839Z","comments":false,"path":"repository/index.html","permalink":"https://www.liuchanggeng.xyz/repository/index.html","excerpt":"","text":""}],"posts":[{"title":"Matlab安装minGW","slug":"softwareGetStart/Matlab安装minGW","date":"2021-05-10T10:38:53.000Z","updated":"2021-05-10T11:03:34.432Z","comments":true,"path":"2021/05/10/softwareGetStart/Matlab安装minGW/","link":"","permalink":"https://www.liuchanggeng.xyz/2021/05/10/softwareGetStart/Matlab%E5%AE%89%E8%A3%85minGW/","excerpt":"","text":"Matlab安装minGW 如果仅仅安装minGw而不需要Matlab使用 可参考 MinGW下载和安装教程 matlab使用minGW可能有版本限制 1mex -setup 123错误使用 mex未找到支持的编译器或 SDK。您可以安装免费提供的 MinGW-w64 C&#x2F;C++ 编译器；请参阅安装 MinGW-w64 编译器。有关更多选项，请访问http:&#x2F;&#x2F;www.mathworks.com&#x2F;support&#x2F;compilers&#x2F;R2016b&#x2F;win64.html。 考虑在附加功能中安装，在附加功能中搜 mingw 安装这个，下载得到 mingw.mlpkginstall文件，用matlab打开它，如果你有多个版本的matlab，可能用错版本，考虑直接将此文件拖到matlab窗口里，或者 1uiopen(&#39;C:\\Users\\LCG\\Documents\\mingw.mlpkginstall&#39;,1) 在高版本Maltab中应该能安装成功。 如果低版本出现 可按照下面方法解决 https://freefr.dl.sourceforge.net/project/tdm-gcc/TDM-GCC%20Installer/Previous/1.1309.0/tdm64-gcc-4.9.2.exe 设置环境变量 1setenv(&#39;MW_MINGW64_LOC&#39;,&#39;C:\\TDM-GCC-64&#39;) 如果还出错，可以参考matlab报错：尝试将 SCRIPT xxx 作为函数执行中的解决办法，即每次在设置中更新工具箱路径缓存","categories":[{"name":"Matlab","slug":"Matlab","permalink":"https://www.liuchanggeng.xyz/categories/Matlab/"}],"tags":[{"name":"软件安装入门","slug":"软件安装入门","permalink":"https://www.liuchanggeng.xyz/tags/%E8%BD%AF%E4%BB%B6%E5%AE%89%E8%A3%85%E5%85%A5%E9%97%A8/"}]},{"title":"同软件多个版本相互冲突","slug":"softwareGetStart/同软件多个版本相互冲突","date":"2021-05-10T06:59:24.000Z","updated":"2021-05-10T07:11:08.700Z","comments":true,"path":"2021/05/10/softwareGetStart/同软件多个版本相互冲突/","link":"","permalink":"https://www.liuchanggeng.xyz/2021/05/10/softwareGetStart/%E5%90%8C%E8%BD%AF%E4%BB%B6%E5%A4%9A%E4%B8%AA%E7%89%88%E6%9C%AC%E7%9B%B8%E4%BA%92%E5%86%B2%E7%AA%81/","excerpt":"","text":"同软件多个版本相互冲突 安装多个版本的Matlab后，在bin文件夹下双击matlab.exe即可打开Matlab，但不同版本的此文件名称相同，如果创建快捷方式后有可能冲突出错。 要保证快捷方式名称不同，并且在各文件夹中名称一致。 下图是开始屏幕相关的文件夹 安装目录","categories":[{"name":"Matlab","slug":"Matlab","permalink":"https://www.liuchanggeng.xyz/categories/Matlab/"}],"tags":[{"name":"软件安装入门","slug":"软件安装入门","permalink":"https://www.liuchanggeng.xyz/tags/%E8%BD%AF%E4%BB%B6%E5%AE%89%E8%A3%85%E5%85%A5%E9%97%A8/"}]},{"title":"stk_matlab_connect","slug":"softwareGetStart/stk-matlab-connect","date":"2021-05-10T03:45:32.000Z","updated":"2021-05-10T10:36:00.819Z","comments":true,"path":"2021/05/10/softwareGetStart/stk-matlab-connect/","link":"","permalink":"https://www.liuchanggeng.xyz/2021/05/10/softwareGetStart/stk-matlab-connect/","excerpt":"","text":"STK 与Matlab 的连接 参考链接： https://help.agi.com/stk/index.htm#install/MATLABsetup.htm 确保STK和Matlab版本兼容 兼容信息也可在连接器文件夹的version.txt中查看 在STK安装文件目录下查找MATLAB_Connectors或MATLAB_Connectors_X64 文件夹 双击 setup.exe Matlab中使用stkInit初始化 添加路径 1addpath(&#x27;D:\\AGI\\STK 11\\bin\\Matlab&#x27;) 但有可能出现以下错误 12345678尝试将 SCRIPT mexConnect 作为函数执行:D:\\AGI\\STK 11\\bin\\Matlab\\mexConnect.m出错 stkValidScen (line 20)out = mexConnect(&#x27;stkValidScen&#x27;);出错 stkInit (line 15)if stkValidScen 解决办法参考链接 STK 与 matlab 连接报错 ： 在运行stkInit前先运行C:\\ProgramData\\AGI\\STK MATLAB文件夹下的startup.m文件","categories":[{"name":"Matlab","slug":"Matlab","permalink":"https://www.liuchanggeng.xyz/categories/Matlab/"},{"name":"STK","slug":"Matlab/STK","permalink":"https://www.liuchanggeng.xyz/categories/Matlab/STK/"}],"tags":[{"name":"软件安装入门","slug":"软件安装入门","permalink":"https://www.liuchanggeng.xyz/tags/%E8%BD%AF%E4%BB%B6%E5%AE%89%E8%A3%85%E5%85%A5%E9%97%A8/"}]},{"title":"Hexo批处理文件","slug":"hexo/hexo-batch-process-file","date":"2020-11-16T07:43:55.000Z","updated":"2020-11-16T08:10:46.667Z","comments":true,"path":"2020/11/16/hexo/hexo-batch-process-file/","link":"","permalink":"https://www.liuchanggeng.xyz/2020/11/16/hexo/hexo-batch-process-file/","excerpt":"","text":"第一次建站，想把以前写过的markdown笔记上传到博客上，但是这些笔记散落在Github的若干repository上，我不想仅仅复制到\\source_posts下，我希望原来的博客路径不变，每次更改github的笔记博客也会变。找了很多办法，都不方便，如将markdown文件渲染成html在用iframe嵌入博客中。 对于VScode中的Markdown Preview Enhanced插件的import功能是我最想要的。可以直接在markdown里插入任意位置markdown，十分方便，但Hexo我没找到插件支持。 本人目前网页技术小白，只好另辟蹊径。 最后写了一个matlab复制脚本，可以时间将其他路径中的markdown笔记复制到目标路径下。这样我可以批量复制所有笔记，每次更新也不用复制粘贴，直接运行脚本就可以了。 12345678910111213%% 用于导入其他文件夹中的md文件%% 设置需要更新的路径(repo的路径)srcpath=[&quot;F:\\github\\Cpp-Notes&quot;; ];% 排除不想复制的文件夹exincludedir=[&quot;.&quot;;&quot;..&quot;;];dstpath=&quot;F:\\github\\blog\\source\\_posts\\test&quot;;%目标文件夹%% 遍历所有路径checkdir(dir(srcpath),1,exincludedir,dstpath); 12345678910111213141516171819202122232425262728%% 检查路径下所有文件% pathlist :文件夹列表% n:第n个文件function checkdir(pathlist,n,exincludedir,dstpath) for ii=n:length(pathlist) ptmp=pathlist(ii); %% 排除 if(sum(ptmp.name==exincludedir)) continue; end nextptmp=[ptmp.folder,&#x27;\\&#x27;,ptmp.name];%子路径 if(isfolder(nextptmp))%是文件夹 nextptmp=[ptmp.folder,&#x27;\\&#x27;,ptmp.name];%子路径 checkdir(dir(nextptmp),1,exincludedir,dstpath); end %后缀 [~,~,abc]=fileparts(ptmp.name); % copy if(abc==&quot;.md&quot;) srcp=[ptmp.folder,&#x27;\\&#x27;,ptmp.name]; if isfolder(dstpath)~=1 mkdir(dstpath) end copyfile(srcp,dstpath); end endend 笔记Front-matter模板 1234567891011---title: Hexo批处理文件mathjax: truedate: 2020-11-16 15:43:55tags: - 建站 - 奇技淫巧categories: - Hexo - Matlab---","categories":[{"name":"Hexo","slug":"Hexo","permalink":"https://www.liuchanggeng.xyz/categories/Hexo/"},{"name":"Matlab","slug":"Hexo/Matlab","permalink":"https://www.liuchanggeng.xyz/categories/Hexo/Matlab/"}],"tags":[{"name":"建站","slug":"建站","permalink":"https://www.liuchanggeng.xyz/tags/%E5%BB%BA%E7%AB%99/"},{"name":"奇技淫巧","slug":"奇技淫巧","permalink":"https://www.liuchanggeng.xyz/tags/%E5%A5%87%E6%8A%80%E6%B7%AB%E5%B7%A7/"}]},{"title":"第一个Hexo博客","slug":"hexo/my-first-hexo-blog","date":"2020-11-14T07:50:34.000Z","updated":"2020-11-17T12:28:56.443Z","comments":true,"path":"2020/11/14/hexo/my-first-hexo-blog/","link":"","permalink":"https://www.liuchanggeng.xyz/2020/11/14/hexo/my-first-hexo-blog/","excerpt":"","text":"参考链接 https://www.cnblogs.com/huanhao/p/hexobase.html https://zhuanlan.zhihu.com/p/26625249 更新博客 新建博客： 1hexo new &quot;新博客标题&quot; 或直接新建一个markdown文件。 本地预览： 1hexo s 上传 123hexo cleanhexo generatehexo deploy 问题 可能博客上传后出现404 在repo的setting中重新save个人域名 主题 相关参考： Hexo 好看的主题推荐 pure主题 测试 数学公式测试 a+b=cπa+b=c\\pi a+b=cπ λ\\lambdaλ","categories":[{"name":"Hexo","slug":"Hexo","permalink":"https://www.liuchanggeng.xyz/categories/Hexo/"}],"tags":[{"name":"Hexo","slug":"Hexo","permalink":"https://www.liuchanggeng.xyz/tags/Hexo/"}]},{"title":"Hello World","slug":"hexo/hello-world","date":"2020-11-13T13:31:20.028Z","updated":"2020-11-15T08:55:51.758Z","comments":true,"path":"2020/11/13/hexo/hello-world/","link":"","permalink":"https://www.liuchanggeng.xyz/2020/11/13/hexo/hello-world/","excerpt":"","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick Start Create a new post 1$ hexo new &quot;My New Post&quot; More info: Writing Run server 1$ hexo server More info: Server Generate static files 1$ hexo generate More info: Generating Deploy to remote sites 1$ hexo deploy More info: Deployment","categories":[],"tags":[]},{"title":"内存对齐","slug":"CPP-Notes/内存对齐","date":"2020-09-12T02:41:00.000Z","updated":"2020-11-16T09:14:38.121Z","comments":true,"path":"2020/09/12/CPP-Notes/内存对齐/","link":"","permalink":"https://www.liuchanggeng.xyz/2020/09/12/CPP-Notes/%E5%86%85%E5%AD%98%E5%AF%B9%E9%BD%90/","excerpt":"","text":"内存对齐 C/C内存对齐详解 C/C 结构体及其数组的内存对齐 现代计算机中内存空间都是按照 byte 划分的，从理论上讲似乎对任何类型的变量的访问可以从任何地址开始，但是实际的计算机系统对基本类型数据在内存中存放的位置有限制，它们会要求这些数据的首地址的值是某个数k（通常它为4或8）的倍数，这就是所谓的内存对齐。 内存对齐规则 每个特定平台上的编译器都有自己的默认“对齐系数”（也叫对齐模数）。gcc中默认#pragma pack(4)，可以通过预编译命令#pragma pack(n)，n = 1,2,4,8,16来改变这一系数。不能用一些奇怪的数，比如3，vscode报错了，但vstudio没报错，怀疑是强转了。 有效对其值：是给定值#pragma pack(n)和结构体中最长数据类型长度中较小的那个。有效对齐值也叫对齐单位。 了解了上面的概念后，我们现在可以来看看内存对齐需要遵循的规则： (1) 结构体第一个成员的偏移量（offset）为0，以后每个成员相对于结构体首地址的 offset 都是该成员大小与有效对齐值中较小那个的整数倍，如有需要编译器会在成员之间加上填充字节。 (3) 结构体的总大小为 有效对齐值 的整数倍，如有需要编译器会在最末一个成员之后加上填充字节。 12345678910111213141516171819202122232425262728293031323334353637#pragma pack(8)//window默认8，linux默认4struct S&#123; char a;//起始偏移0-&gt;0 int b;//偏移min(8,4)=4-&gt;0XXX0000 short c;//偏移min(8,2)=2(8是2的倍数，不需要补齐)-&gt;0xxx|0000|00 double d;//min(8,8)=8(10不是8的倍数-&gt;16-&gt;补六位)-&gt;0xxx|0000|00xxxxxx|00000000//24&#125;;class C&#123;public: char a; int b; short c;&#125;;//同上，结构体对齐10-&gt;12(和长度最长成员的对齐)int main()&#123; S s; C c; printf(&quot;%x\\n&quot;, &amp;s.a); printf(&quot;%x\\n&quot;, &amp;s.b); printf(&quot;%x\\n&quot;, &amp;s.c); printf(&quot;%x\\n&quot;, &amp;s.d); printf(&quot;%x\\n&quot;, &amp;c.a); printf(&quot;%x\\n&quot;, &amp;c.b); printf(&quot;%x\\n&quot;, &amp;c.c); cout &lt;&lt; sizeof(s) &lt;&lt; endl; cout &lt;&lt; sizeof(c) &lt;&lt; endl; cout &lt;&lt; sizeof(s.a) &lt;&lt; endl; cout &lt;&lt; sizeof(s.b) &lt;&lt; endl; cout &lt;&lt; sizeof(s.c) &lt;&lt; endl; cout &lt;&lt; sizeof(s.d) &lt;&lt; endl; cout &lt;&lt; sizeof(double) &lt;&lt; endl; return 0; windows debug 86 123456789101112131410ff7d810ff7dc10ff7e010ff7e810ff7c410ff7c810ff7cc241214288 #pragma pack(4) , windows debug 86 1234567891011121314f5fadcf5fae0f5fae4f5fae8f5fac8f5faccf5fad0201214288 #pragma pack(1)即各变量内存总和 结构体内的数组(如int a[10])可以认为连续有10个int的变量。 1234567#pragma pack(8)struct test &#123; int a;//0-&gt;4 char b;//4-&gt;1 short c;//6-&gt;2 char d[17];//8-&gt;16+1=25&#125;;//25补上3个字节后是min(8,int)的倍数 28 C与指针：根据边界对齐要求降序排列结构体成员可以最大限度减少存储中浪费的内存空间。 union 参考：C与指针211页 union，中文名“联合体、共用体”，在某种程度上类似结构体struct的一种数据结构，共用体(union)和结构体(struct)同样可以包含很多种数据类型和变量。 一个联合体的所有成员都存储在内部的同一位置，通过访问不同类型的联合成员，内存中相同的位组合可以被解释为不同的东西，联合在实现变体记录(内存中某个特定的区域将在不同的时刻存储不同类型的值)时很有用，但程序员必须负责确认实际存储的是那个变体并选择正确的联合成员以便访问数据。联合变量也可以进行初始化，但初始值必须为联合第一个成员的类型匹配（如果不匹配的话编译器会强转，可能的话，如double-&gt;int）。 区别： 结构体(struct)中所有变量是“共存”的——优点是“有容乃大”，全面；缺点是struct内存空间的分配是粗放的，不管用不用，全分配。 而联合体(union)中是各变量是“互斥”的——缺点就是不够“包容”；但优点是内存使用更为精细灵活，也节省了内存空间(一般不用数组，用指针代替数组，这样就不会又太大的变量)。 union联合体所有数据成员共享一段内存，后写入的成员数据将覆盖之前的成员数据，成员数据都有相同的首地址。 内存对齐规则：没找到，自己猜的，以最大的变量(数组算总长度)为内部内存占的空间，然后按结构体的内存对齐思想，找内部最大的类型(数组算单个长度)和#pragma pack(n)中最小的，以此倍数补齐。 123456#pragma pack(8)typedef union&#123; char a[2]; char b[999];&#125;un;//sizeof(un))=999; 123456#pragma pack(8)typedef union&#123; short a[2]; char b[999];&#125;un;//sizeof(un))=1000;以short的倍数补齐 位段/位域(bit field) 参考：C与指针 http://c.biancheng.net/view/2037.html 如果冒号后面不加位数，会自动按类型的原本长度如int，char等分配。 概要： 移植性 signed unsigned 内存分配方向 操作系统位数，位段最大长度(不能超过类型长度int，char等) 总结：位段允许长度为奇数的一些值包装在一起以节省存储空间，源代码如果需要访问一个值内部的一些位，使用位段比较简单(也可以通过移位和屏蔽实现，目标代码中两种实现方式无区别)，位段是结构的一种，但它的长度以位为大卫指定，位段声明在本质上是不可移植的(也能移植，但需要考虑太多因素) 百度 例题 12345678910111213#pragma pack(8)typedef union&#123; long i; char j[10]; int k;&#125;Data;//最长10，按最大类型long4字节倍数-&gt;10-&gt;12struct data1&#123; int m;//4 Data n;// min(12,8)=8,4-&gt;8,8+12=20 double i;//min(8,8)=8=&gt;20-&gt;24,24+8=32;&#125;test;//最长12，32-&gt;12*3=36 C 库宏 offsetof(type, member-designator) 会生成一个类型为 size_t 的整型常量，它是一个结构成员相对于结构开头的字节偏移量。成员是由 member-designator 给定的，结构的名称是在 type 中给定的 以下运行结果和我预想的不一致，没搞明白，有时间再看。就是结构体各首地址应该多少？为什么和分配内存对齐的结果不一致，难道是因为地址这样做方便程序员不考虑内存对齐就可以用指针指向具体成员？内部系统自己再转换成对齐后的地址？？？ 123456cout &lt;&lt; (int)offsetof(struct data1, m) &lt;&lt; endl;//0cout &lt;&lt; (int)offsetof(struct data1, n) &lt;&lt; endl;//4cout &lt;&lt; (int)offsetof(struct data1, i) &lt;&lt; endl;//16printf(&quot;%d\\n&quot;, &amp;data1::m);//0printf(&quot;%d\\n&quot;, &amp;data1::n);//4printf(&quot;%d\\n&quot;, &amp;data1::i);//16 1234printf(&quot;%d\\n&quot;, &amp;test);printf(&quot;%d\\n&quot;, &amp;test.m);printf(&quot;%d\\n&quot;, &amp;test.n);printf(&quot;%d\\n&quot;, &amp;test.i); 12346340928634092863409326340944","categories":[{"name":"C/C++","slug":"C-C","permalink":"https://www.liuchanggeng.xyz/categories/C-C/"}],"tags":[{"name":"学习笔记","slug":"学习笔记","permalink":"https://www.liuchanggeng.xyz/tags/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"}]},{"title":"深浅拷贝","slug":"CPP-Notes/深浅拷贝","date":"2020-09-09T03:43:00.000Z","updated":"2020-11-16T09:15:23.275Z","comments":true,"path":"2020/09/09/CPP-Notes/深浅拷贝/","link":"","permalink":"https://www.liuchanggeng.xyz/2020/09/09/CPP-Notes/%E6%B7%B1%E6%B5%85%E6%8B%B7%E8%B4%9D/","excerpt":"","text":"深浅拷贝 浅拷贝：使用类的默认拷贝构造函数，按字节复制，对于指针型变量只复制指针本身。不会复制指针所指向的目标，两个成员指向相同的内存空间，可能造成多次释放。 没有指针时，浅拷贝是可行的。 深拷贝，自定义拷贝构造函数。 简单的测试，浅拷贝： 1234567891011121314151617181920212223242526272829303132333435363738394041424344class A2&#123;public: A2() :a(0),pa(nullptr) &#123;&#125;; ~A2() &#123; cout &lt;&lt; &quot;~A2()&quot; &lt;&lt; endl; delete[] pa; &#125; void SetValue(int b) &#123; if (pa != nullptr) &#123; delete[] pa; &#125; pa = new int; *pa = b; a = b; &#125; void GetValue() &#123; cout &lt;&lt; &quot;a: &quot; &lt;&lt; a &lt;&lt; endl; cout &lt;&lt; &quot;&amp;a: &quot; &lt;&lt; &amp;a &lt;&lt; endl; cout &lt;&lt; &quot;*pa: &quot; &lt;&lt; pa &lt;&lt; endl; cout &lt;&lt; &quot;pa: &quot; &lt;&lt; *pa &lt;&lt; endl; cout &lt;&lt; endl; &#125; private: int a; int* pa;&#125;;int main()&#123; A2 a21; &#123; A2 a2; a2.SetValue(10); a2.GetValue(); a21 = a2; a21.GetValue(); &#125;//a2被析构 a21.GetValue(); return 0;&#125; 结果 123456789101112131415a: 10&amp;a: 012FF80C*pa: 01600550pa: 10a: 10&amp;a: 012FF81C//对象的地址不同*pa: 01600550//指针的值相同pa: 10~A2()a: 10&amp;a: 012FF81C//*pa: 01600550pa: -572662307//浅拷贝，内存已释放 深拷贝 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657class A1&#123;public: A1() :a(0), pa(nullptr) &#123;&#125;; ~A1() &#123; cout &lt;&lt; &quot;~A2()&quot; &lt;&lt; endl; delete[] pa; &#125; void SetValue(int b) &#123; if (pa != nullptr) &#123; delete[] pa; &#125; pa = new int; *pa = b; a = b; &#125; void GetValue() &#123; cout &lt;&lt; &quot;a: &quot; &lt;&lt; a &lt;&lt; endl; cout &lt;&lt; &quot;&amp;a: &quot; &lt;&lt; &amp;a &lt;&lt; endl; cout &lt;&lt; &quot;*pa: &quot; &lt;&lt; pa &lt;&lt; endl; cout &lt;&lt; &quot;pa: &quot; &lt;&lt; *pa &lt;&lt; endl; cout &lt;&lt; endl; &#125; A1&amp; operator=(const A1&amp; a1) &#123; if (&amp;a1 != this) &#123; this-&gt;a = a1.a; int* tmp = new int; if (pa != nullptr) delete[] pa; *tmp = *a1.pa; pa = tmp; &#125; return *this; &#125;private: int a; int* pa;&#125;;int main()&#123; A1 a11; &#123; A1 a1; a1.SetValue(10); a1.GetValue(); a11 = a1; a11.GetValue(); &#125; a11.GetValue();&#125; 123456789101112131415a: 10&amp;a: 0133F7F0*pa: 017A0550pa: 10a: 10&amp;a: 0133F800&#x2F;&#x2F;对象的地址不同*pa: 017A8D98&#x2F;&#x2F;指针的值不同pa: 10~A2()a: 10&amp;a: 0133F800*pa: 017A8D98&#x2F;&#x2F;析构后不受影响pa: 10 123456789101112131415161718192021222324252627class Person&#123;public: Person()&#123;&#125; explicit Person(const char* str_, int len) : strLen(len)&#123; str = (char*)malloc(sizeof(char)*len); strcpy(str, str_); &#125; ~Person()&#123; if (str != nullptr)&#123; free(str); str = nullptr; &#125; &#125; //深拷贝 Person&amp; operator=(const Person&amp; person)&#123; if (this == &amp;person) return *this;//(错误(*this == person) ) free(str); strLen = person.strLen; str = (char *)malloc(sizeof(char) * (strLen+1)); memset(str, &#x27;\\0&#x27;, strLen); strcpy(str, person.str); return *this; &#125;private: char* str; int strLen;&#125;;","categories":[{"name":"C/C++","slug":"C-C","permalink":"https://www.liuchanggeng.xyz/categories/C-C/"}],"tags":[{"name":"学习笔记","slug":"学习笔记","permalink":"https://www.liuchanggeng.xyz/tags/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"}]},{"title":"设计模式","slug":"CPP-Notes/设计模式","date":"2020-09-02T09:36:00.000Z","updated":"2020-11-16T09:05:03.761Z","comments":true,"path":"2020/09/02/CPP-Notes/设计模式/","link":"","permalink":"https://www.liuchanggeng.xyz/2020/09/02/CPP-Notes/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/","excerpt":"","text":"设计模式 “每一个模式描述了一个在我们周围不断重复发生的问题，以及该问题的解决方案的核心。这样，你就能一次又一次地使用该方案而不必做重复劳动”。 当客户改变需求，可以很快改变 理解松耦合设计思想 掌握面向对象设计原则 掌握重构技法改善设计 掌握GOF 核心设计模式 设计模式目标：可复用 具体方法：面向对象 复用性：真正的复用性不是代码复用，是编译单位的复用性，二进制的复用性，在原来的代码后面加几行不是复用之前的代码，已经破坏了代码的结构，也可能会引起bug。 程序员要想到以后代码会扩展的情况。 如何解决复杂性？ 分解 人们面对复杂性有一个常见的做法：即分而治之，将大问题分解为多个小问题，将复杂问题分解为多个简单问题。 抽象 更高层次来讲，人们处理复杂性有一个通用的技术，即抽象。由于不能掌握全部的复杂对象，我们选择忽视它的非本质细节，而去处理泛化和理想化了的对象模型。 多态可以使得接口保持一致，新增不同的设计方法。 面向对象设计原则 依赖倒置原则（DIP） 高层模块(稳定)不应该依赖于低层模块(变化)，二者都应该依赖于抽象(稳定) 。 抽象(稳定)不应该依赖于实现细节(变化) ，实现细节应该依赖于抽象(稳定)。 修改低层会影响高层 抽象不变 开放封闭原则（OCP）(开闭原则) 对扩展开放，对更改封闭。 类模块应该是可扩展的，但是不可修改。 单一职责原则(SRP) 一个类已更改仅有一个引起它变化的原因 变化的方向隐含着类的责任 Liskov替换原则(LSP),里氏代换原则,is a的另外一种表达方式 子类必须能够替换他们的基类(IS-A)，(设计子类不应该不能使用父类功能) 继承表达类型抽象 接口隔离原则（ISP） 不应该强迫客户程序依赖他们不用的方法 接口应该小而完备 优先使用对象组合，和不是类继承 类继承通常为&quot;白箱复用&quot;，对象组合通常为“黑箱复用”。 继承在某种程度上破坏了封装性(父类给子类暴露的较多)，子类父类耦合度高 而对象组合则只要求被组合的对象具有良好定义的接口，耦合度低。 (有点像我在调制识别时写的helper类，这个类和识别类不是继承关系，写成对象组合，即一个类里面定义了另一个类) 封装变化点 使用封装来创建对象之间的分界层，让设计者可以在分界层进行修改，而不会对另一侧产生不良的影响，从而是实现层次间的松耦合。 封装的作用不仅仅是封装代码和数据，更高层次的理解是封装变化和稳定，一侧变化，一侧稳定。(参考依赖倒置原则的两个图，感觉项目中通过一个大的信号生成类去隔离各种调制信号生成方式类就是这种思想) 针对接口编程，而不是针对实现编程(依赖倒置原则的另一个角度。往往违背其中一个原则，另一个原则也会违背) 不讲变量声明为某个特定的具体类，而是声明为某个接口。 客户程序无需获知对象的具体类型，只需要知道对象所具有的接口。 减少系统中各部分的依赖关系，从而实现“高内聚，低耦合” 违背接口原则 12vector&lt;Line&gt; lineVector;vector&lt;Rect&gt; rectVector; 面向接口的设计 123vector&lt;Shape*&gt; shapeVector;//放抽象接口...shapeVector[i]-&gt;Draw(e.Graphics);//多态调用，各负其值 面向接口设计 产业强盛的标志，接口设计是一种专门的工作，可以分工协作，才能实现复用性。 重构关键技法 静态-&gt;动态 早绑定-&gt;晚绑定 继承-&gt;组合 编译时依赖-&gt;运行时依赖 紧耦合-&gt;松耦合 设计模式就是在稳定和和变化中找到隔离点。 https://blog.csdn.net/huashuolin001/article/details/108258802 https://www.jianshu.com/p/69eef7651667 https://www.runoob.com/design-pattern/design-pattern-intro.html 单例模式-创建型模式 https://blog.csdn.net/sinat_21107433/article/details/102649056 如window任务管理器，回收站，多线程线程池，文件系统，一个数字滤波器只有一个AD转换器，一个会计系统专用于一个公司 一个类只有一个实例，该类能自行创建实例 类的构造函数(注意析构函数不影响)设为私有的，外部类就无法调用该构造函数，也就无法生成多个实例。 写法： 懒汉式： 线程不安全 加锁(代价过高) 双检测锁(reorder:编译器指令重排) C++11双检测锁（m_mutex） C11局部静态变量(Effictive C的作者提出的) 饿汉式 线程安全 线程不安全的写法 懒汉式: 123456789101112131415161718class Singleton&#123;private: static Singleton* m_instance;//这里是类指针 Singleton() &#123;&#125;;//不能delete，否则getInstance调用不了 Singleton(const Singleton&amp; other) = delete;//不希望有拷贝构造public: static Singleton* getInstance();//获得实例&#125;;Singleton* Singleton::m_instance = nullptr;//开头不用写staticSingleton* Singleton::getInstance()//这里开头也不用写static&#123; if (m_instance == nullptr)//懒汉：使用时创建 &#123; m_instance = new Singleton(); &#125; return m_instance;&#125; 线程安全的写法(代价过高) 123456789Singleton* Singleton::getInstance() &#123; Lock lock;// if (m_instance == nullptr) &#123; m_instance = new Singleton(); &#125; return m_instance;&#125; 双检查锁（错误的写法） 1234567891011121314151617181920////双检查锁，但由于内存读写reorder不安全，出问题概率很高，不能这么用//假想顺序//step1 :分配内存//step2：构造//step3：返回指针//编译器reorder：CPU指令级(有可能，编译优化)：//step1 : 分配内存//step2：返回指针//step3：构造Singleton* Singleton::getInstance() &#123; if(m_instance==nullptr)&#123;//第一个判空为了判断是第一次创建 Lock lock;//两个线程只有一个能先锁，不能都锁上 if (m_instance == nullptr) &#123;//第二个判空是为了当两个线程同时判空后，一个先锁，让一个先new出来后另一个直接跳过，否则还是会多次创建。 m_instance = new Singleton();//可能在某个线程new的时候未分配内存就返回指针，导致其他线程判不为空，返回了一个错误的指针 &#125; &#125; return m_instance;&#125; C++11双检测锁,内存栅栏 12345678910111213141516171819//C++ 11版本之后的跨平台实现 (volatile)std::atomic&lt;Singleton*&gt; Singleton::m_instance;std::mutex Singleton::m_mutex;Singleton* Singleton::getInstance() &#123; Singleton* tmp = m_instance.load(std::memory_order_relaxed); std::atomic_thread_fence(std::memory_order_acquire);//获取内存fence if (tmp == nullptr) &#123; std::lock_guard&lt;std::mutex&gt; lock(m_mutex); tmp = m_instance.load(std::memory_order_relaxed); if (tmp == nullptr) &#123; tmp = new Singleton; std::atomic_thread_fence(std::memory_order_release);//释放内存fence m_instance.store(tmp, std::memory_order_relaxed); &#125; &#125; return tmp;&#125; 局部静态变量(最好的写法) https://blog.csdn.net/wang_anna/article/details/103761565 123456//类内static Singleton* getInstance()&#123; static Singleton m_instance;//是个对象 return &amp;m_instance;//返回地址&#125; 饿汉式，线程安全 该模式的特点是类一旦加载就创建一个单例，保证在调用 getInstance 方法之前单例已经存在了。 不管是不是用都会初始化，浪费内存 123//1.在类中new//2.在类外newSingleton* Singleton::m_instance = new Singleton(); 模板模式(template Pattern)-类行为型模式 https://blog.csdn.net/sinat_21107433/article/details/102994585 就是在基类中把算法的框架搭好，在子类中去实现。框架是不变的部分，将可变的行为留给子类。变的部分写成虚函数，子类重写实现虚函数。 非模板模式 12345678910111213//程序库开发人员class Library&#123;public: void Step1()&#123; //... &#125; void Step3()&#123; //... &#125; void Step5()&#123; //... &#125;&#125;; 1234567891011121314151617181920212223//应用程序开发人员class Application&#123;public: bool Step2()&#123; //... &#125; void Step4()&#123; //... &#125;&#125;;int main()&#123; Library lib(); Application app(); lib.Step1(); if (app.Step2())&#123; lib.Step3(); &#125; for (int i = 0; i &lt; 4; i++)&#123; app.Step4(); &#125; lib.Step5();&#125; 模板模式 1234567891011121314151617181920212223242526272829//程序库开发人员class Library&#123;public: //稳定 template method void Run()&#123; Step1(); if (Step2()) &#123; //支持变化 ==&gt; 虚函数的多态调用 Step3(); &#125; for (int i = 0; i &lt; 4; i++)&#123; Step4(); //支持变化 ==&gt; 虚函数的多态调用 &#125; Step5(); &#125; virtual ~Library()&#123; &#125;protected: void Step1() &#123; //稳定 //..... &#125; void Step3() &#123;//稳定 //..... &#125; void Step5() &#123; //稳定 //..... &#125; virtual bool Step2() = 0;//变化 virtual void Step4() =0; //变化&#125;; 123456789101112131415161718//应用程序开发人员class Application : public Library &#123;protected: virtual bool Step2()&#123; //... 子类重写实现 &#125; virtual void Step4() &#123; //... 子类重写实现 &#125;&#125;;int main()&#123; Library* pLib=new Application(); pLib-&gt;Run(); delete pLib;&#125; 模板方法模式是基于类的继承的一种设计模式，使用非常频繁，被广泛应用于框架设计。 优点： 在基类中定义算法的框架，并声明一些流程方法，由具体派生类实现细节，派生类中的实现并不会影响基类定义的算法的框架流程； 公共行为在基类中提供实现，有利于代码复用； 派生类可以覆盖基类的方法，重新实现某些方法，具有灵活性； 可以很方便的扩展和更换派生类而不影响基类和其他派生类，符合开闭原则和单一职责原则。 缺点： 模板方法模式要为每一个不同的基本方法提供一个派生类，如果基类中基本方法很多，那系统中会定义很多个派生类，导致类的个数很多，系统更加庞大。 工厂模式(Factory Method)对象创建型模式 别名：虚构造器 “对象创建”模式 通过“对象创建” 模式绕开new，来避免对象创建（new）过程中所导致的紧耦合（依赖具体类），从而支持对象创建的稳定。它是接口抽象之后的第一步工作。 定义一个用于创建对象的接口，让子类决定实例化哪一个类，使一个类的实例化延迟(目的：解耦，手段：虚函数virtual)到子类. 一般适用于不确定new后面的类是什么类型，或者希望由子类指定所创建的对象的时候。 优点： 1、一个调用者想创建一个对象，只要知道其名称就可以了。 2、扩展性高，如果想增加一个产品，只要扩展一个工厂类就可以。 3、屏蔽产品的具体实现，调用者只关心产品的接口。 缺点：每次增加一个产品时，都需要增加一个具体类和对象实现工厂，使得系统中类的个数成倍增加，在一定程度上增加了系统的复杂度，同时也增加了系统具体类的依赖。这并不是什么好事 12345678910111213141516//抽象类class ISplitter&#123;public: virtual void split()=0; virtual ~ISplitter()&#123;&#125;&#125;;//工厂基类class SplitterFactory&#123;public: virtual ISplitter* CreateSplitter()=0;//返回new出来的对象指针 //virtual ISplitter1* CreateSplitter()=0;如果有多个ISplitter并且相互有联系，可以都在这里写成虚函数，这样写就是抽象工厂。 //virtual ISplitter2* CreateSplitter()=0; virtual ~SplitterFactory()&#123;&#125;&#125;; 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647//具体类class BinarySplitter : public ISplitter&#123; &#125;;class TxtSplitter: public ISplitter&#123; &#125;;class PictureSplitter: public ISplitter&#123; &#125;;class VideoSplitter: public ISplitter&#123; &#125;;//具体工厂class BinarySplitterFactory: public SplitterFactory&#123;public: virtual ISplitter* CreateSplitter()&#123; return new BinarySplitter(); &#125;&#125;;class TxtSplitterFactory: public SplitterFactory&#123;public: virtual ISplitter* CreateSplitter()&#123; return new TxtSplitter(); &#125;&#125;;class PictureSplitterFactory: public SplitterFactory&#123;public: virtual ISplitter* CreateSplitter()&#123; return new PictureSplitter(); &#125;&#125;;class VideoSplitterFactory: public SplitterFactory&#123;public: virtual ISplitter* CreateSplitter()&#123; return new VideoSplitter(); &#125;&#125;; 12345678910111213141516class MainForm : public Form&#123; SplitterFactory* factory;//工厂public: MainForm(SplitterFactory* factory)&#123;//SplitterFactory是基类，传进来子类 this-&gt;factory=factory; &#125; void Button1_Click()&#123; ISplitter * splitter= factory-&gt;CreateSplitter(); //多态new ，返回一个ISplitter的子类，new隐藏在CreateSplitter里 splitter-&gt;split(); &#125;&#125;; 抽象工厂 -对象创建型 和工厂模式十分相似，解决的问题也差不多。工厂模式是抽象工厂的特例。当工厂基类中的要扩展的虚函数只有一个时，就是工厂模式，多个时，就是抽像工厂，因为这多个虚函数之间有相互依赖性，如果定义多个基类，不好处理。 高内聚，松耦合。 “对象创建”模式 通过“对象创建” 模式绕开new，来避免对象创建（new）过程中所导致的紧耦合（依赖具体类），从而支持对象创建的稳定。它是接口抽象之后的第一步工作。 动机（Motivation） 在软件系统中，经常面临着“一系列相互依赖的对象”(和工厂模式的区别)的创建工作；同时，由于需求的变化，往往存在更多系列对象的创建工作。 如何应对这种变化？如何绕过常规的对象创建方法(new)，提供一种“封装机制”来避免客户程序和这种“多系列具体对象创建工作”的紧耦合？ GOF定义-提供一个接口，让该接口负责创建一系列“相关或者相互依赖的对象”，无需指定它们具体的类。 策略模式-组件协作模式 “组件协作”模式: 现代软件专业分工之后的第一个结果是“框架与应用程序的划分”，“组件协作”模式通过晚期绑定，来实现框架与应用程序之间的松耦合，是二者之间协作时常用的模式。 动机（Motivation） 在软件构建过程中，某些对象使用的算法可能多种多样，经常改变，如果将这些算法都编码到对象中，将会使对象变得异常复杂；而且有时候支持不使用的算法也是一个性能负担(如果使用if else，那么所有的代码都会放到代码段里，大量代码可能造成负担，装载到CPU的高级缓存等等被迫挤到主存或内存里，而写成多态的，就没问题))。 如何在运行时根据需要透明地更改对象的算法？将算法与对象本身解耦，从而避免上述问题？ 定义一系列算法，把它们一个个封装起来，并且使它们可互相替换（变化）。该模式使得算法可独立于使用它的客户程序(稳定)而变化（扩展，子类化）。 ——《设计模式》GoF 违背开闭原则 12345678910111213141516171819202122232425262728293031enum TaxBase &#123; CN_Tax, US_Tax, DE_Tax, FR_Tax //更改&#125;;class SalesOrder&#123; TaxBase tax;public: double CalculateTax()&#123; //... if (tax == CN_Tax)&#123; //CN*********** &#125; else if (tax == US_Tax)&#123; //US*********** &#125; else if (tax == DE_Tax)&#123; //DE*********** &#125; else if (tax == FR_Tax)&#123; //更改 //... &#125; //.... &#125; &#125;; 策略模式 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162class TaxStrategy&#123;public: virtual double Calculate(const Context&amp; context)=0; virtual ~TaxStrategy()&#123;&#125;&#125;;class CNTax : public TaxStrategy&#123;public: virtual double Calculate(const Context&amp; context)&#123; //*********** &#125;&#125;;class USTax : public TaxStrategy&#123;public: virtual double Calculate(const Context&amp; context)&#123; //*********** &#125;&#125;;class DETax : public TaxStrategy&#123;public: virtual double Calculate(const Context&amp; context)&#123; //*********** &#125;&#125;;//扩展//*********************************class FRTax : public TaxStrategy&#123;public: virtual double Calculate(const Context&amp; context)&#123; //......... &#125;&#125;;class SalesOrder&#123;private: TaxStrategy* strategy;//多态指针public: SalesOrder(StrategyFactory* strategyFactory)&#123; this-&gt;strategy = strategyFactory-&gt;NewStrategy(); &#125; ~SalesOrder()&#123; delete this-&gt;strategy; &#125; public double CalculateTax()&#123; //... Context context(); double val = strategy-&gt;Calculate(context); //多态调用 //... &#125; &#125;; 观察者模式-组合 “组件协作”模式: 现代软件专业分工之后的第一个结果是“框架与应用程序的划分”，“组件协作”模式通过晚期绑定，来实现框架与应用程序之间的松耦合，是二者之间协作时常用的模式。 动机（Motivation） 在软件构建过程中，我们需要为某些对象建立一种“通知依赖关系” ——一个对象（目标对象）的状态发生改变，所有的依赖对象（观察者对象）都将得到通知。如果这样的依赖关系过于紧密，将使软件不能很好地抵御变化。 使用面向对象技术，可以将这种依赖关系弱化，并形成一种稳定的依赖关系。从而实现软件体系结构的松耦合。","categories":[{"name":"C/C++","slug":"C-C","permalink":"https://www.liuchanggeng.xyz/categories/C-C/"}],"tags":[{"name":"学习笔记","slug":"学习笔记","permalink":"https://www.liuchanggeng.xyz/tags/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"}]},{"title":"11新特性","slug":"CPP-Notes/C++11新特性","date":"2020-08-30T07:56:00.000Z","updated":"2020-11-16T09:16:48.547Z","comments":true,"path":"2020/08/30/CPP-Notes/C++11新特性/","link":"","permalink":"https://www.liuchanggeng.xyz/2020/08/30/CPP-Notes/C++11%E6%96%B0%E7%89%B9%E6%80%A7/","excerpt":"","text":"C++11新特性 右值引用","categories":[{"name":"C/C++","slug":"C-C","permalink":"https://www.liuchanggeng.xyz/categories/C-C/"}],"tags":[{"name":"学习笔记","slug":"学习笔记","permalink":"https://www.liuchanggeng.xyz/tags/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"}]},{"title":"STL-侯捷","slug":"CPP-Notes/侯捷STL","date":"2020-08-29T11:56:00.000Z","updated":"2020-11-16T09:10:14.204Z","comments":true,"path":"2020/08/29/CPP-Notes/侯捷STL/","link":"","permalink":"https://www.liuchanggeng.xyz/2020/08/29/CPP-Notes/%E4%BE%AF%E6%8D%B7STL/","excerpt":"","text":"STL 1234&lt;iterator&gt; &lt;functional&gt; &lt;vector&gt; &lt;deque&gt;&lt;list&gt; &lt;queue&gt; &lt;stack&gt; &lt;set&gt;&lt;map&gt; &lt;algorithm&gt; &lt;numeric&gt; &lt;memory&gt;&lt;utility&gt; 6大部件： STL可分为容器(containers)、迭代器(iterators)、空间配置器(allocator)、配接器(adapters)、算法(algorithms)、仿函数(functors)六个部分。 最常用的是容器和算法，在使用算法时，不需要考虑内存的分配与释放，这是由分配器完成的，算法通过迭代器操作于容器。 迭代器时前闭后开区间，[)，.end()指向最后一个元素下一个元素，迭代器是泛化的指针。 容器分类 序列式的： 关联式容器：可用来快速查找，红黑树实现，set,map,multiset,multimap 不定序容器：也可以认为是关联式的，unordered_set/unordered_map/unordered_multiset/unordered_multimap/ 如果标准库自己提供sort，优先用自己的。 slist: include&lt;ext\\slist&gt;和forward list相同，forward list是标准库中的，slist是早期的 deque 分段连续，前后可扩充。 模板 模板优缺点 面向对象是数据和方法放一起。 泛型是数据和方法分开。（通过接口传数据，如algorithm中的迭代器） 模板分类 函数模板:调用时可以不显示指定类型，模板可以重载 类模板：必须显示指定类型 成员模板(不常用) 类模板里面有全特化和偏特化 偏特化有个数上的偏，也有范围上的偏 全特化，为指定类型执行特殊的程序，优化算法。 注意开头是 1template&lt;&gt; 偏特化 默认的分配器allocator 也可以自定义 容器 分类 迭代器的设计原则 iterator_traits 萃取 iterator有5种associated types相当于迭代器的属性，想用迭代器时使用方法要根据迭代器的这几个特性设计，如algorithm调用迭代器时需要知道这些特性。 iterator_category 单双向 value_type 容器的值类型 pointer 暂时未用 reference 暂时未用 difference_type 用来表示两个迭代器之间的距离 algorithm如果传进来的是指针(退化的迭代器) 则通过偏特化让算法知道这是指针。 容器rb_tree","categories":[{"name":"C/C++","slug":"C-C","permalink":"https://www.liuchanggeng.xyz/categories/C-C/"}],"tags":[{"name":"学习笔记","slug":"学习笔记","permalink":"https://www.liuchanggeng.xyz/tags/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"}]},{"title":"类多态","slug":"CPP-Notes/类多态","date":"2020-08-29T06:46:00.000Z","updated":"2020-11-16T09:13:31.328Z","comments":true,"path":"2020/08/29/CPP-Notes/类多态/","link":"","permalink":"https://www.liuchanggeng.xyz/2020/08/29/CPP-Notes/%E7%B1%BB%E5%A4%9A%E6%80%81/","excerpt":"","text":"类多态 参考资料 虚函数表 多态（Polymorphism）按字面的意思就是“多种状态”。在面向对象语言中，接口的多种不同的实现方式即为多态。引用Charlie Calverts对多态的描述——多态性是允许你将父对象设置成为一个或更多的他的子对象相等的技术，赋值之后，父对象就可以根据当前赋值给它的子对象的特性以不同的方式运作（摘自“Delphi4 编程技术内幕”）。简单的说，就是一句话：允许将子类类型的指针赋值给父类类型的指针。多态性在Object Pascal和C++中都是通过虚函数实现的。 override 覆盖,也可以说是重写，但和overwrite重写不一样，是翻译的问题，直接说英文。 作为关键字，放在虚函数后面(形参列表后面，或者在const成员函数的const后面，或者是在引用成员函数的引用限定符&amp;后面) 覆盖要和虚函数的形参列表相同，不同的话就是一个独立的函数和基类没关系。但是一般不这么用，多数情况下是写错了才这么用的，这时编译器很难检测出来，为了方便调试，C++11 引入override关键字，当有这个关键字并且形参列表不同时，编译器会报错。 final(C++11) 放在类名后面，则该类不能作为基类，避免继承。 放在虚函数后面，则派生类不能override此函数(不能放在非虚函数后面) 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455#ifndef CLASS_TEST_H#define CLASS_TEST_Hclass A&#123;public: A():a(0),b(0) &#123;&#125;; ~A() &#123;&#125;; void func1(int a); void func1(double a);//重载 virtual void func2(int a); virtual void func3(int a); //virtual void func4(int a)=0; private: int a;protected: int b;&#125;;class A2&#123;public: A2() :a(0), b(0) &#123;&#125;; ~A2() &#123;&#125;; //void func1(int a); virtual void func1(int a)=0;//纯虚函数private: int a;protected: int b;&#125;;class B:public A&#123;public: void func1();//重写/隐藏。非虚函数 void func1(int a);//重写/隐藏 void func3(int a) override;//覆盖，编译器一般翻译成重写(但不是overwrite)，override,也是虚函数(隐式的)，也可以在前面加上virtual(显式) void func3(int a, int b);//这是一个独立的函数，和基类没关系， //不是覆盖(因为形参列表不同，如果加上overrid关键字编译器会报错)，也不是重写(重写是基类的非虚);&#125;;class B2 :public A2&#123;public: B2():A2()&#123;&#125;; ~B2(); void func1(int a);&#125;;#endif // !CLASS_TEST_H 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758#include &quot;class_test.h&quot;#include &lt;iostream&gt;using namespace std;//class Avoid A::func1(int a)&#123; cout &lt;&lt; &quot;class A:func1(int)&quot;&lt;&lt;a &lt;&lt; endl;&#125;void A::func1(double a)&#123; cout &lt;&lt; &quot;class A:func1(double)&quot; &lt;&lt; a &lt;&lt; endl;&#125;void A::func2(int a)&#123; cout &lt;&lt; &quot;class A virtual func2(int a)&quot; &lt;&lt; a &lt;&lt; endl;&#125;void A::func3(int a)&#123; cout &lt;&lt; &quot;class A virtual func3(int a)&quot; &lt;&lt; a &lt;&lt; endl;&#125;//class A2void A2::func1(int a)&#123; cout &lt;&lt; &quot;class A2:func1(int a)&quot; &lt;&lt; a &lt;&lt; endl;&#125;//class Bvoid B::func1()&#123; cout &lt;&lt; &quot;class B:func1&quot; &lt;&lt; endl;&#125;void B::func1(int a)&#123; cout &lt;&lt; &quot;class B:func1(int)&quot; &lt;&lt;a &lt;&lt;endl;&#125;void B::func3(int a)&#123; cout &lt;&lt; &quot;class B:func3(int a)&quot; &lt;&lt; a&lt;&lt;endl;&#125;void B::func3(int a, int b)&#123; cout &lt;&lt; &quot;class B:func3(int a, int b)&quot; &lt;&lt; a &lt;&lt; b &lt;&lt; endl;&#125;void B2::func1(int a)&#123; cout &lt;&lt; &quot;class B2:func1(int a)&quot; &lt;&lt; a &lt;&lt; endl;&#125; 1234567891011121314151617181920212223242526272829303132333435363738#include&quot;class_test.h&quot;int main()&#123; A clsA; clsA.func1(1); clsA.func1(1.1);//重载 B claB; claB.func1(); claB.func1(2); claB.A::func1(2);//通过作用域改变调用函数 claB.func2(3);//B中没有func2 claB.func3(3);//B中有func3，覆盖 claB.A::func3(3);//通过作用域改变调用函数 claB.func3(3,4);//独立的函数 A *claAB=new B; claAB = &amp;claB;//子类指针可以赋给父类指针，反之不能 /* 导致错误输出的原因是，调用函数 func1() 被编译器设置为基类中的版本， 这就是所谓的静态多态，或静态链接 - 函数调用在程序执行前就准备好了。 有时候这也被称为早绑定，因为 func1() 函数在程序编译期间就已经设置好了。*/ claAB-&gt;func1(4);//静态多态，静态链接，早绑定 ((B*)claAB)-&gt;func1(5); ((B*)claAB)-&gt;func2(5);//B中没有func2 claAB-&gt;func3(6);//动态多态，动态链接，后绑定 B* pclaB; pclaB = &amp;claB; pclaB-&gt;func1(5);//重写，overwrite，隐藏了基类函数，注意和早绑定的区别 //A2 claA2;//错误，不能使用纯虚拟函数的对象 // A2* pclasA2 = new A2();//错误，不能使用纯虚拟函数的对象 A2* pclasA2 = new B2();//子类指针赋值给基类 pclasA2-&gt;func1(1); //B2 claB2; B2* pclaB2 = new B2(); pclaB2-&gt;func1(1); return 0;&#125; typeid 在c++中，typeid用于返回指针或引用所指对象的实际类型。 typeid是操作符，不是函数. 对非引用类型，typeid是在编译时期识别的，只有引用类型才会在运行时识别。 12345int a;const type_info &amp; info=typeid(a);cout &lt;&lt; info.name() &lt;&lt; endl;//类型的名称cout &lt;&lt; info.raw_name() &lt;&lt; endl;//名字编码（Name Mangling）算法产生的新名称cout &lt;&lt; info.hash_code() &lt;&lt; endl;//返回当前类型对应的 hash 值 123int.H3440116983","categories":[{"name":"C/C++","slug":"C-C","permalink":"https://www.liuchanggeng.xyz/categories/C-C/"}],"tags":[{"name":"学习笔记","slug":"学习笔记","permalink":"https://www.liuchanggeng.xyz/tags/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"}]},{"title":"智能指针","slug":"CPP-Notes/智能指针","date":"2020-08-27T03:30:00.000Z","updated":"2020-11-16T09:16:01.710Z","comments":true,"path":"2020/08/27/CPP-Notes/智能指针/","link":"","permalink":"https://www.liuchanggeng.xyz/2020/08/27/CPP-Notes/%E6%99%BA%E8%83%BD%E6%8C%87%E9%92%88/","excerpt":"","text":"智能指针 参考资料 C++11中智能指针的原理、使用、实现 使用 智能指针在C++11版本之后提供，包含在头文件 &lt;memory&gt;中，shared_ptr、unique_ptr、weak_ptr(伴随类)","categories":[{"name":"C/C++","slug":"C-C","permalink":"https://www.liuchanggeng.xyz/categories/C-C/"}],"tags":[{"name":"学习笔记","slug":"学习笔记","permalink":"https://www.liuchanggeng.xyz/tags/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"}]},{"title":"STL-笔记","slug":"CPP-Notes/STLNotes","date":"2020-08-26T03:05:00.000Z","updated":"2020-11-16T09:09:53.248Z","comments":true,"path":"2020/08/26/CPP-Notes/STLNotes/","link":"","permalink":"https://www.liuchanggeng.xyz/2020/08/26/CPP-Notes/STLNotes/","excerpt":"","text":"参考 http://www.cplusplus.com/reference/stl/ 分类 顺序容器 关联容器 有序容器（红黑树） 无序容器（哈希表） 通用接口 类型别名 iterator const_iterator size_type difference_type value_type reference const_reference 构造函数 赋值 assign(仅顺序容器) 123a.assign(it1,it2);//给定迭代器范围进行赋值a.assign(&#123;1,2,3,4&#125;);//列表赋值a.assign(n,t);//n个t assign允许从一个不同但相容的类型赋值。 123456789101112131415list&lt;string&gt; names; vector&lt;const char*&gt; old; char* tmp = new char[3]; tmp[0] = &#x27;7&#x27;; tmp[1] = &#x27;8&#x27;; tmp[2] = &#x27;\\0&#x27;; char tmp2[4] = &quot;abc&quot;; //names.push_back(&quot;123&quot;); //names.push_back(&quot;456&quot;); old.push_back(tmp); old.push_back(tmp2); names.assign(old.cbegin(), old.cend()); for (auto i : names) cout &lt;&lt; i &lt;&lt; &quot; &quot;;//78 abc cout &lt;&lt; endl; array的assign不能按上述用，a.assign(1)是把assign所有位置都变成1. swap 常数时间交换两个相同容器的内容。元素本身并未交换，只是交换了数据结构(比如迭代器的指向) 但是array特殊，相当于数组。会真正交换其元素。也不是常数时间。 对string调用swap会导致迭代器、引用和指针失效。 12345678910string s1(&quot;123&quot;);string s2(&quot;456&quot;);string::iterator it0 = s1.begin();swap(s1, s2);//s1.swap(s2);auto it1 = s1.begin();cout &lt;&lt; *it0 &lt;&lt; endl;//迭代器失效cout &lt;&lt; *it1 &lt;&lt; endl;//4cout &lt;&lt; s1 &lt;&lt; endl;//456cout &lt;&lt; s2 &lt;&lt; endl;//123 1234567891011vector&lt;int&gt; v1 = &#123;1,2,3&#125;;vector&lt;int&gt; v2 = &#123;4,5,6,7&#125;;auto it0 = v1.begin();swap(v1, v2);auto it1 = v1.begin();cout &lt;&lt; *it0 &lt;&lt; endl;//未失效，1cout &lt;&lt; *it1 &lt;&lt; endl;//4for (auto i : v1)cout &lt;&lt; i &lt;&lt; &quot; &quot;; cout &lt;&lt; endl;//4567for (auto i : v2)cout &lt;&lt; i &lt;&lt; &quot; &quot;; cout &lt;&lt; endl;//123 大小 empty size 不支持forward_list max_size capacity,reserce,shrink_to_fit capacity,reserve只适用于vector和string reserve永远不会减少容量，只能用shrink_to_fit减少。 shrink_to_fit将capacity减少为于size相同大小，并请求将超出当前大小的多余内存退回给操作系统，但只是一个请求，并不能保证一定退还内存，这是操作系统的事。 1234567vector&lt;int&gt;a;for (int i = 0; i &lt; 100; ++i) a.push_back(i);cout &lt;&lt; a.size() &lt;&lt; endl;//100cout &lt;&lt; a.capacity() &lt;&lt; endl;//141a.shrink_to_fit();cout &lt;&lt; a.size() &lt;&lt; endl;//100cout &lt;&lt; a.capacity() &lt;&lt; endl;//100 每次扩容当大小超过capacity时，都要重新分配大小，将原有的元素移到新位置，释放旧内存，vector的扩张操作通常比list和deque快。 扩容分配策略遵循原则：通过一个初始为空的vector上调用n次push_back()来创建n个元素所花费的时间不能超过n的常数倍。 获取迭代器 反向容器的额外成员 添加 vector,deuqe,string等插入元素会使迭代器，指针，引用失效。 在vector的尾部以外或者deque的首尾以外任何地方添加元素，都可能引起整个对象存储空间的重新分配。重新分配内存，将元素从旧的地址空格键移动到新的空间中。 forward_list不支持push_back和empace_back,有自己专属的emplace和insert push_back,push_front,push 传进去的是对象的一个拷贝，而不是对象本身。 emplace_back,emplace_front,emplace emplace_back,emplace_front,emplace分别对应push_back,push_front和insert操作。 区别是当我们调用emplace成员函数时，是将参数传递给元素类型的构造函数，emplace成员使用这些参数在容器管理的内存空间中直接构造元素。而push_back()则会创建一个局部临时对象，并将其压入容器。 insert 12345678vector&lt;int&gt; a = &#123;1,2,3&#125;; auto iter = a.begin(); for (int i = 0; i &lt; 10; ++i) &#123; iter = a.insert(iter, i);//反复插元素，返回的是新插入的位置的迭代器 &#125; for (auto i : a)cout &lt;&lt; i &lt;&lt; &quot; &quot;; cout &lt;&lt; endl; //9 8 7 6 5 4 3 2 1 0 1 2 3 访问 返回的是引用 at 只适合vector，deque，string，array 越界则抛出out_of_range异常。 [] 1234567vector&lt;int&gt; a = &#123; 1,2,3 &#125;;auto atmp = a[1];atmp = 10;for (auto i : a)cout &lt;&lt; i &lt;&lt; &quot; &quot;; cout &lt;&lt; endl;//1 10 3auto&amp; atmp2 = a[1];atmp2 = 10;for (auto i : a)cout &lt;&lt; i &lt;&lt; &quot; &quot;; cout &lt;&lt; endl;// 1 2 3 vector 初始化 12345678vector&lt;int&gt;a(10);vector&lt;int&gt;b(10,1);vector&lt;int&gt;c=&#123;1,2,3,4,5,6&#125;;vector&lt;int&gt;d(&#123;1,2,3&#125;);vector&lt;int&gt;e(c);vector&lt;int&gt;f(c.begin(), c.begin() + 6);vector&lt;int&gt;g(&amp;c[0], &amp;c[5]+1);vector&lt;int&gt;e(c,c+6); 各接口 1234567891011121314151617vector&lt;int&gt;a=&#123;1,2,3,4,5,6&#125;;a.push_back();a.pop_back();a.emplace_back();a.empty();a.size();b.max_size();//可保存的最大元素数目a.capacity();a.resize(100);a.reserve(100);a.assign();a[1];a.at(1);a.data();a.clear();a.earse();a.swap(b);; 两种访问方式： 12vector::at()//进行边界检查，效率低于[]，超出边界会抛出exception。vector::operator[]//可能月越界，访问效率高 在release模式下,[]越界不会报错，at()会触发异常。 删除 clear(),pop_back(),erase() 1234567891011121314151617181920212223bool cmp(int x)&#123; if (x &lt; 5) return false; return true;&#125; vector&lt;int&gt; b; b.push_back(1); b.push_back(2); b.push_back(3); b.push_back(4); b.push_back(5); b.push_back(6); auto it = b.begin(); b.erase(it + 1); for (auto i : b) cout &lt;&lt; i &lt;&lt; &quot; &quot;; cout &lt;&lt; endl; // auto it2 = remove(b.begin(), b.end(), 5); auto it2 = remove_if(b.begin(), b.end(), cmp); b.erase(it2,b.end()); for (auto i : b) cout &lt;&lt; i &lt;&lt; &quot; &quot;; b.clear(); vector&lt;bool&gt;较为特殊：可以参考http://www.cplusplus.com/reference/vector/vector-bool/ 还有bitset(位图)和valarray(支持高速运算的数组) emplace 参考资料 emplace_back减少内存拷贝和移动 C++11 起 push_back 需要分配新内存时一般都是把元素移动构造过去，而非复制构造。 在vector文件中debug push_back()和emplace_back()的源码。观察函数调用 12345678910111213141516171819202122#include &lt;map&gt;struct Complicated&#123; int year; double country; std::string name; Complicated(int a, double b, string c) :year(a), country(b), name(c) &#123; cout &lt;&lt; &quot;is constucted&quot; &lt;&lt; endl; &#125; Complicated(const Complicated&amp; other) :year(other.year), country(other.country), name(std::move(other.name)) &#123; cout &lt;&lt; &quot;is moved&quot; &lt;&lt; endl; &#125; ~Complicated() &#123; cout &lt;&lt; &quot;Deconstruction&quot; &lt;&lt; endl; &#125;&#125;; 1234567891011121314151617181920std::map&lt;int, Complicated&gt; m;int anInt = 4;double aDouble = 5.0;std::string aString = &quot;C++&quot;;cout &lt;&lt; &quot;—insert--&quot; &lt;&lt; endl;m.insert(std::make_pair(4, Complicated(anInt, aDouble, aString)));cout &lt;&lt; &quot;—emplace--&quot; &lt;&lt; endl;// should be easier for the optimizer m.emplace(4, Complicated(anInt, aDouble, aString));cout &lt;&lt; &quot;--emplace_back--&quot; &lt;&lt; endl;vector&lt;Complicated&gt; v;v.emplace_back(anInt, aDouble, aString);cout &lt;&lt; &quot;--两步push_back--&quot; &lt;&lt; endl;Complicated tmp(anInt, aDouble, aString);//v.push_back(Complicated(anInt, aDouble, aString));v.push_back(tmp);cout &lt;&lt; &quot;--一步push_back--&quot; &lt;&lt; endl;v.push_back(Complicated(anInt, aDouble, aString)); array 定义时，必须要指定类型和大小，底层有数组实现，所以和数组很像，但可以比数组功能强，如可以直接用=进行array之间的赋值。 不支持assign 不支持列表赋值。 deque 双端队列 double-ended queue 的缩写，又称双端队列容器。 双端队列(deque) 连续存储的指向不同元素的指针所组成的数组 分段连续，然后串接 list 双向链表 1234567891011121314151617181920212223#include&lt;list&gt;void TestList()&#123; list&lt;int&gt; l; l.push_back(0); l.push_back(4); l.push_back(5); list&lt;int&gt; l2; l2.push_back(1); l2.push_back(2); l2.push_back(3); auto it = l.begin(); advance(it, 1);//迭代器不能自增，所以想要得到特定位置迭代器，需要调用此函数 l.insert(it, l2.begin(), l2.end()); for (auto i : l)cout &lt;&lt; i &lt;&lt; &quot; &quot;; cout &lt;&lt; endl; list&lt;int&gt; l3 = &#123;-3,-2,-1&#125;; it = l.begin(); l.splice(it, l3);//splice删除list的部分或全部元素，并拼接到另一个list的迭代器的位置处。 for(auto i:l) cout &lt;&lt; i &lt;&lt; &quot; &quot;; cout &lt;&lt; endl; cout &lt;&lt; l3.size() &lt;&lt; endl;//l3已经被清除&#125; stack栈 先进后出 queue 先进先出,底层结构：deque/list，没有迭代器 123456#include&lt;queue&gt;queue&lt;int&gt; q;q.push(1);q.pop();q.front();q.back(); forward_list 迭代器不支持（–） 不支持反向容器的额外成员 set/multiset 1234template &lt; class T, // 键 key 和值 value 的类型 class Compare = less&lt;T&gt;, // 指定 set 容器内部的排序规则 class Alloc = allocator&lt;T&gt; // 指定分配器对象的类型 &gt; class set; 1234567891011121314151617set&lt;int&gt; set1 = &#123;4,3,2,1&#125;;set1.insert(5);set1.emplace(6);for (int i : set1) cout &lt;&lt; i &lt;&lt; &quot; &quot;; cout &lt;&lt; endl;auto it = set1.find(3);it++; cout &lt;&lt; *it &lt;&lt; endl;it = set1.find(0);cout &lt;&lt;std::boolalpha&lt;&lt; (it==set1.end()) &lt;&lt; endl;it = set1.lower_bound(3); cout &lt;&lt; *it &lt;&lt; endl;it = set1.upper_bound(3); cout &lt;&lt; *it &lt;&lt; endl;auto it2 = set1.equal_range(3); cout &lt;&lt; *it2.first &lt;&lt;&quot; &quot;&lt;&lt;*it2.second&lt;&lt; endl;cout &lt;&lt; set1.size() &lt;&lt; endl;it = set1.find(1);set1.erase(it);set1.erase(2);set1.erase(100);for (int i : set1) cout &lt;&lt; i &lt;&lt; &quot; &quot;; cout &lt;&lt; endl; 123456781 2 3 4 5 64true343 463 4 5 6 123456789101112131415161718192021222324multiset&lt;int&gt; mset1;mset1.insert(4);mset1.insert(3);mset1.insert(2);mset1.insert(2);mset1.insert(2);mset1.insert(5);mset1.emplace(6);cout &lt;&lt; mset1.count(2) &lt;&lt; endl;for (int i : mset1) cout &lt;&lt; i &lt;&lt; &quot; &quot;; cout &lt;&lt; endl;auto it = mset1.find(3);it++; cout &lt;&lt; *it &lt;&lt; endl;it = mset1.find(0);cout &lt;&lt; std::boolalpha &lt;&lt; (it == mset1.end()) &lt;&lt; endl;it = mset1.lower_bound(2); cout &lt;&lt; *it &lt;&lt; endl;it = mset1.upper_bound(2); cout &lt;&lt; *it &lt;&lt; endl;auto it2 = mset1.equal_range(2); cout &lt;&lt; *it2.first &lt;&lt; &quot; &quot; &lt;&lt; *it2.second &lt;&lt; endl;cout &lt;&lt; mset1.size() &lt;&lt; endl;it= mset1.find(2);mset1.erase(it);//删除一个for (int i : mset1) cout &lt;&lt; i &lt;&lt; &quot; &quot;; cout &lt;&lt; endl;mset1.erase(2);//删除所有mset1.erase(100);for (int i : mset1) cout &lt;&lt; i &lt;&lt; &quot; &quot;; cout &lt;&lt; endl; 1234567891032 2 2 3 4 5 64true232 372 2 3 4 5 63 4 5 6 map/multimap 关联容器，不允许相同的key，存储的对象必须可排序。 12345template &lt; class Key, // 指定键（key）的类型 class T, // 指定值（value）的类型 class Compare = less&lt;Key&gt;, // 指定排序规则 class Alloc = allocator&lt;pair&lt;const Key,T&gt; &gt; // 指定分配器对象的类型 &gt; class map; 1234567map&lt;int,char&gt;mp1;mp1[0] = 0 + &#x27;0&#x27;;//可直接赋值mp1[0] = 0 + &#x27;0&#x27;;cout &lt;&lt; mp1.count(0) &lt;&lt; endl;for (int i = 5; i &gt;= 0; --i) mp1.emplace(i, i + &#x27;0&#x27;);//直接构造mp1.insert(make_pair(6, 6 + &#x27;0&#x27;));for (auto i : mp1)cout &lt;&lt; i.second &lt;&lt; &quot; &quot;; cout &lt;&lt; endl; 1210 1 2 3 4 5 6 12345678910multimap&lt;int, char&gt;mp1;//mp1[0] = 0 + &#x27;0&#x27;;//不可直接赋值for (int i = 5; i &gt;= 0; --i) mp1.emplace(i, i + &#x27;0&#x27;);//直接构造mp1.insert(make_pair(6, 6 + &#x27;0&#x27;));mp1.insert(make_pair(0, 0 + &#x27;0&#x27;));//重复的也会压进去mp1.insert(make_pair(0, 7 + &#x27;0&#x27;));mp1.insert(make_pair(0, 8 + &#x27;0&#x27;));cout &lt;&lt; mp1.count(0) &lt;&lt; endl;for (auto i : mp1)cout &lt;&lt; i.second &lt;&lt; &quot; &quot;; cout &lt;&lt; endl;for (auto it = mp1.begin(); it != mp1.end(); ++it)cout &lt;&lt; it-&gt;first &lt;&lt; &quot; &quot; &lt;&lt; it-&gt;second &lt;&lt; endl; 12345678910111240 0 7 8 1 2 3 4 5 60 00 00 70 81 12 23 34 45 56 6 哈希表 哈希表（散列表）详解（包含哈希表处理冲突的方法） 哈希函数：f（）是一个函数，通过这个函数可以快速求出该关键字对应的的数据的哈希地址，称之为“哈希函数” 哈希冲突：对于哈希表而言，冲突只能尽可能地少，无法完全避免。 哈希地址：哈希地址只是表示在查找表中的存储位置，而不是实际的物理存储位置。 常用的哈希函数的构造方法有 6 种： 直接定址法：其哈希函数为一次函数，H（key）= key 或者 H（key）=a * key + b，其中 H（key）表示关键字为 key 对应的哈希地址，a 和 b 都为常数。 数字分析法 ：如果关键字由多位字符或者数字组成，就可以考虑抽取其中的 2 位或者多位作为该关键字对应的哈希地址，在取法上尽量选择变化较多的位，避免冲突发生。 平方取中法：关键字做平方操作，取中间得几位作为哈希地址。 折叠法 除留余数法：若已知整个哈希表的最大长度 m，可以取一个不大于 m 的数 p，然后对该关键字 key 做取余运算，即：H（key）= key % p，在此方法中，对于 p 的取值非常重要，由经验得知 p 可以为不大于 m 的质数或者不包含小于 20 的质因数的合数。 随机数法：是取关键字的一个(伪)随机函数值作为它的哈希地址，即：H（key）=random（key），此方法适用于关键字长度不等的情况。 处理冲突的方法 开放定址法 ： H（key）=（H（key）+ d）MOD m（其中 m 为哈希表的表长，d 为一个增量） 当得出的哈希地址产生冲突时，选取以下 3 种方法中的一种获取 d 的值，然后继续计算，直到计算出的哈希地址不在冲突为止，这 3 种方法为： 线性探测法：d=1，2，3，…，m-1 二次探测法：d=12，-12，22，-22，32，… 伪随机数探测法：d=伪随机数 再哈希法 链地址法 建立一个公共溢出区 unordered 关联式容器的底层实现采用的树存储结构，更确切的说是红黑树结构； 无序容器的底层实现采用的是哈希表的存储结构。 C++ STL 底层采用哈希表实现无序容器时，会将所有数据存储到一整块连续的内存空间中，并且当数据存储位置发生冲突时，解决方法选用的是“链地址法”（又称“开链法”）。 无序容器内部存储的键值对是无序的，各键值对的存储位置取决于该键值对中的键， 和关联式容器相比，无序容器擅长通过指定键查找对应的值（平均时间复杂度为 O(1)）；但对于使用迭代器遍历容器中存储的元素，无序容器的执行效率则不如关联式容器。 https://blog.csdn.net/wusecaiyun/article/details/46723363 123456789101112map, set, multimap, and multiset上述四种容器采用红黑树实现，红黑树是平衡二叉树的一种。不同操作的时间复杂度近似为:插入: O(logN)查看:O(logN)删除:O(logN)hash_map, hash_set, hash_multimap, and hash_multiset上述四种容器采用哈希表实现，不同操作的时间复杂度为：插入:O(1)，最坏情况O(N)。查看:O(1)，最坏情况O(N)。删除:O(1)，最坏情况O(N)。记住，如果你采用合适的哈希函数，你可能永远不会看到最坏情况。但是记住这一点是有必要的。","categories":[{"name":"C/C++","slug":"C-C","permalink":"https://www.liuchanggeng.xyz/categories/C-C/"}],"tags":[{"name":"学习笔记","slug":"学习笔记","permalink":"https://www.liuchanggeng.xyz/tags/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"}]},{"title":"大量数据处理","slug":"CPP-Notes/大量数据处理","date":"2020-08-23T13:26:00.000Z","updated":"2020-11-16T09:10:53.407Z","comments":true,"path":"2020/08/23/CPP-Notes/大量数据处理/","link":"","permalink":"https://www.liuchanggeng.xyz/2020/08/23/CPP-Notes/%E5%A4%A7%E9%87%8F%E6%95%B0%E6%8D%AE%E5%A4%84%E7%90%86/","excerpt":"","text":"bitMap 可以运用在快速查找、去重、排序、压缩数据等。 将整数n放置在第n个bit位，扫描后按左至右或右至左输入即为排好序的。 https://www.cnblogs.com/dyllove98/archive/2013/07/26/3217741.html https://www.cnblogs.com/senlinyang/p/7885685.html 题目：一个10G的文件，里面全部是自然数，一行一个，乱序排列，对其排序。在32位机器上面完成，内存限制为 2G。 首先来分析一下题目，10G的文件，只有2G内存，显然，不可能一次性把数据放入内存中直接排序。那么，还有什么其他办法呢？遍寻资料，可以发现大致有两种解决方案： 1、把大文件分成多个小文件，分别排序，到最后合并成一个文件（我暂时还没搞懂这个方法，所以不会描述，有兴趣的看官可以自己去查一下）； 2、另外一种方法就是著名的bitmap算法了。 https://www.jianshu.com/p/bf9dbbc147ed 12345678910111213141516171819202122232425262728293031323334353637383940//arr[n]的第m位置1void setBit(int num,int arr[])&#123; int n = num / 32; int m = num % 32; arr[n] += (1 &lt;&lt; m);&#125;//地位至高位打印void printBitMap(int arr[],int len)&#123; for (int i = 0; i&lt;len; i++) &#123; int n = 1; for (int ii = 0; ii &lt; 32; ++ii) &#123; if ((arr[i] &amp; n) == n)//这里时==n，不是==1 &#123; cout &lt;&lt; i * 32 + ii &lt;&lt; endl; &#125; n &lt;&lt;= 1; &#125; &#125;&#125;void clr(int arr[], int len)&#123; for (int i = 0; i &lt; len; ++i) arr[i] = 0;&#125;int main()&#123; int arr[100]; int arr2[10] = &#123; 100,800,22,314,21,44,0,1,3,2 &#125;; clr(arr,100); for(int i = 0; i &lt; 10; ++i) &#123; setBit(arr2[i], arr); &#125; printBitMap(arr, 100); return 0;&#125; 123456789100123212244100314800 bitset https://www.cnblogs.com/RabbitHu/p/bitset.html http://www.cplusplus.com/reference/bitset/bitset/ C++封装的bitMap，是模板类 12345678910111213#include&lt;bitset&gt;int main()&#123; bitset&lt;32&gt; bs(3);//相当于...0011 // bs.set(3); cout &lt;&lt; bs.count() &lt;&lt; endl;//3 bs.set(4);//第5位置1 cout &lt;&lt; bs.size() &lt;&lt; endl;//32 cout &lt;&lt; bs.to_string() &lt;&lt; endl;//00000000000000000000000000010011 cout &lt;&lt; bs.to_ullong() &lt;&lt; endl;//19 return 0;&#125; 123456789101112#include&lt;bitset&gt;int main()&#123; bitset&lt;1000&gt; bs; vector&lt;int&gt; arr = &#123; 9,2,4,12,100,900,788,20 &#125;; for (auto a : arr) bs.set(a); cout &lt;&lt;&quot;count: &quot; &lt;&lt;bs.count() &lt;&lt; endl; for (int i = 0; i &lt; bs.size(); i++) if (bs[i] == 1) cout &lt;&lt; i &lt;&lt; &quot; &quot;;&#125; 12count: 82 4 9 12 20 100 788 900","categories":[{"name":"C/C++","slug":"C-C","permalink":"https://www.liuchanggeng.xyz/categories/C-C/"}],"tags":[{"name":"学习笔记","slug":"学习笔记","permalink":"https://www.liuchanggeng.xyz/tags/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"}]},{"title":"STL-迭代器","slug":"CPP-Notes/迭代器","date":"2020-08-20T09:36:00.000Z","updated":"2020-11-16T09:07:40.898Z","comments":true,"path":"2020/08/20/CPP-Notes/迭代器/","link":"","permalink":"https://www.liuchanggeng.xyz/2020/08/20/CPP-Notes/%E8%BF%AD%E4%BB%A3%E5%99%A8/","excerpt":"","text":"迭代器","categories":[{"name":"C/C++","slug":"C-C","permalink":"https://www.liuchanggeng.xyz/categories/C-C/"}],"tags":[{"name":"学习笔记","slug":"学习笔记","permalink":"https://www.liuchanggeng.xyz/tags/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"}]},{"title":"STL-algorithm","slug":"CPP-Notes/algorithm","date":"2020-08-19T09:36:00.000Z","updated":"2020-11-16T09:08:09.789Z","comments":true,"path":"2020/08/19/CPP-Notes/algorithm/","link":"","permalink":"https://www.liuchanggeng.xyz/2020/08/19/CPP-Notes/algorithm/","excerpt":"","text":"STL algorithm 泛型算法本身不会执行容器的操作，他们只会运行迭代器之上。永远不会添加和删除元素。不是说容器经过算法后容器大小不变，而是算法会通过使用迭代器而控制容器，而不是直接控制容器。如插入器(inserter) remove 移除指定元素 remove_if c++ remove_if remove_if()并不会实际移除序列[start, end)中的元素; 如果在一个容器上应用remove_if(), 容器的长度并不会改变(remove_if()不可能仅通过迭代器改变容器的属性), 所有的元素都还在容器里面. 实际做法是, remove_if()将所有应该移除的元素都移动到了容器尾部并返回一个分界的迭代器. 移除的所有元素仍然可以通过返回的迭代器访问到. 为了实际移除元素, 你必须对容器自行调用erase()以擦除需要移除的元素. 1container.erase(remove_if(container.begin(), container.end(), pred), container.end());","categories":[{"name":"C/C++","slug":"C-C","permalink":"https://www.liuchanggeng.xyz/categories/C-C/"}],"tags":[{"name":"学习笔记","slug":"学习笔记","permalink":"https://www.liuchanggeng.xyz/tags/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"}]},{"title":"STL-适配器(adaptor)","slug":"CPP-Notes/适配器","date":"2020-08-19T03:13:00.000Z","updated":"2020-11-16T09:10:03.749Z","comments":true,"path":"2020/08/19/CPP-Notes/适配器/","link":"","permalink":"https://www.liuchanggeng.xyz/2020/08/19/CPP-Notes/%E9%80%82%E9%85%8D%E5%99%A8/","excerpt":"","text":"适配器(adaptor) 本质上，适配器是一种机制，能使某种事物的行为看起来像另外一种事物一样。一个容器适配器接受一种已有的容器类型，使其行为看起来像一种不同的类型(stack接受一个除array和forward_list外的顺序容器)。 通常适配器内部不怎么操作，而总是调用底层操作。 标准库中的顺序容器适配器 stack queue priority_queue 每个适配器有两个构造函数： 默认构造函数：构造空对象 拷贝构造函数:可接受适配的容器 123deque&lt;int&gt; deq;stack&lt;int&gt; stk(deq);//从deq中拷贝元素到stk 适配器都有添加和删除和访问尾元素的能力，所以不能构造在array上，同理，forward_list也不能用来构造适配器。","categories":[{"name":"C/C++","slug":"C-C","permalink":"https://www.liuchanggeng.xyz/categories/C-C/"}],"tags":[{"name":"学习笔记","slug":"学习笔记","permalink":"https://www.liuchanggeng.xyz/tags/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"}]},{"title":"结构体内长度为0的数组","slug":"CPP-Notes/结构体长度为0的数组","date":"2020-08-04T17:34:00.000Z","updated":"2020-11-16T09:13:03.483Z","comments":true,"path":"2020/08/05/CPP-Notes/结构体长度为0的数组/","link":"","permalink":"https://www.liuchanggeng.xyz/2020/08/05/CPP-Notes/%E7%BB%93%E6%9E%84%E4%BD%93%E9%95%BF%E5%BA%A6%E4%B8%BA0%E7%9A%84%E6%95%B0%E7%BB%84/","excerpt":"","text":"结构体内长度为0的数组 参考资料 C语言0长度数组(可变数组/柔性数组)详解 *结构体中数组下标为0 思考一种场景：需要一个结构体，结构体中的需要一个缓冲区，用于接收不定长数据。则最可能想到的就是两种解决方案： 1234567891011121314151617181920212223242526//1.开辟定长大缓冲区，用定长数组#define MaxLength 1024struct S1&#123; int len;//实际数据长度len&lt;MaxLength int data[MaxLength];&#125;;int main()&#123; int data[10] = &#123; 0,1,2,3,4,5,6,7,8,9 &#125;; int len = 10; struct S1* pS1; int data[10] = &#123; 0,1,2,3,4,5,6,7,8,9 &#125;; int len = 10; if (pS1 = (struct S1*)malloc(sizeof(S1))) &#123; pS1-&gt;len = len; memcpy(pS1-&gt;data, data,sizeof(pS1-&gt;data[0])*len); &#125; free(pS1); pS1 = nullptr; return 0;&#125; 1234567891011121314151617181920212223//结构体里使用指针做缓冲区struct S2&#123; int len; int* data;&#125;;int main()&#123; int data[10] = &#123; 0,1,2,3,4,5,6,7,8,9 &#125;; int len = 10; struct S2* pS2; if (pS2 = (struct S2*)malloc(sizeof(S2)))//一步 &#123; if (pS2-&gt;data = (int*)malloc(sizeof(int) * len))//两部 &#123; //两次分配的内存是不连续的, 需要分别对其进行管理 memcpy(pS2-&gt;data, data, sizeof(int) * len); &#125; &#125; free(pS2-&gt;data); free(pS2); pS2 = nullptr;&#125; 使用指针结果作为缓冲区, 只多使用了一个指针大小的空间, 无需使用 一定 长度的数组, 不会造成空间的大量浪费. 但那是开辟空间时, 需要额外开辟数据域的空间, 释放时候也需要显示释放数据域的空间, 但是实际使用过程中, 往往在函数中开辟空间, 然后返回给使用者指向 struct point_buffer 的指针, 这时候我们并不能假定使用者了解我们开辟的细节, 并按照约定的操作释放空间, 因此使用起来多有不便, 甚至造成内存泄漏。 定长数组使用方便, 但是却浪费空间, 指针形式只多使用了一个指针的空间, 不会造成大量空间分浪费, 但是使用起来需要多次分配, 多次释放, 那么有没有一种实现方式能够既不浪费空间, 又使用方便的呢? GNU C 的0长度数组, 也叫变长数组, 柔性数组就是这样一个扩展. 对于0长数组的这个特点，很容易构造出变成结构体，如缓冲区，数据包等等： 123456789101112131415161718struct S3&#123; int len; int data[0];&#125;;int main()&#123; int data[10] = &#123; 0,1,2,3,4,5,6,7,8,9 &#125;; int len = 10; struct S3* pS3; if (pS3 = (struct S3*)malloc(sizeof(struct S3) + sizeo (int) * len))//len这里不分配也可以memcpy,但free会出问题 &#123; memcpy(pS3-&gt;data, data, sizeof(int) * len); &#125; free(pS3); pS3 = nullptr; return 0;&#125;","categories":[{"name":"C/C++","slug":"C-C","permalink":"https://www.liuchanggeng.xyz/categories/C-C/"}],"tags":[{"name":"学习笔记","slug":"学习笔记","permalink":"https://www.liuchanggeng.xyz/tags/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"}]},{"title":"函数指针","slug":"CPP-Notes/函数指针","date":"2020-07-28T02:04:00.000Z","updated":"2020-11-16T09:12:21.789Z","comments":true,"path":"2020/07/28/CPP-Notes/函数指针/","link":"","permalink":"https://www.liuchanggeng.xyz/2020/07/28/CPP-Notes/%E5%87%BD%E6%95%B0%E6%8C%87%E9%92%88/","excerpt":"","text":"函数指针 参考资料 typedef int (*MYFUN)(int, int) 1234567891011#pragma once#ifndef FUNC_PTR_H#define FUNC_PTR_Htypedef int (*pfint)(int);int func1(int a);int func2(int a);int* func3(int &amp;a);#endif // ! FUNC_PTR_H 12345678910111213141516171819202122#include &quot;func_ptr.h&quot;#include&lt;iostream&gt;using namespace std;int func1(int a)&#123; cout &lt;&lt; &quot;func1: &quot; &lt;&lt; a &lt;&lt; endl; cout &lt;&lt; &quot;&amp;func1: &quot; &lt;&lt; &amp;func1 &lt;&lt; endl; return a;&#125;int func2(int a)&#123; cout &lt;&lt; &quot;func2: &quot; &lt;&lt; a &lt;&lt; endl; return a;&#125;int* func3(int &amp;a)//需要传引用，如果传值，返回的是局部变量的地址&#123; cout &lt;&lt; &quot;func3: &quot; &lt;&lt; a &lt;&lt; endl; return &amp;a;&#125; 12345678910111213141516171819202122232425#include &quot;func_ptr.h&quot;int main()&#123; func1(1); func2(2); int (*pfunc)(int) = &amp;func1; cout &lt;&lt; pfunc &lt;&lt; endl; (*pfunc)(3); pfunc = func2;//函数名被使用时总是由编译器转化为函数指针 cout &lt;&lt; pfunc &lt;&lt; endl; (*pfunc)(4); pfunc = &amp;func2; (*pfunc)(5); pfunc(6);//间接访问非必需，因为编译器需要的是一个函数指针 pfint pfint1; pfint1 = func1; pfint1(2); int (*funcArr[2])(int); funcArr[0] = func1; funcArr[1] = func2; funcArr[0](1); funcArr[1](2); return 0;&#125; 可以new出来函数指针吗?没找到有这么写的。","categories":[{"name":"C/C++","slug":"C-C","permalink":"https://www.liuchanggeng.xyz/categories/C-C/"}],"tags":[{"name":"学习笔记","slug":"学习笔记","permalink":"https://www.liuchanggeng.xyz/tags/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"}]},{"title":"this指针","slug":"CPP-Notes/this指针","date":"2020-07-25T07:23:00.000Z","updated":"2020-11-16T09:18:37.825Z","comments":true,"path":"2020/07/25/CPP-Notes/this指针/","link":"","permalink":"https://www.liuchanggeng.xyz/2020/07/25/CPP-Notes/this%E6%8C%87%E9%92%88/","excerpt":"","text":"this指针 123456789101112#ifndef THIS_TEST_H#define THIS_TEST_Hclass ThisTest&#123;public: void func1(int a,int b); static void func2();private: int a;&#125;;#endif // !THIS_TEST_H 12345678910111213141516171819202122#include &quot;this_test.h&quot;#include&lt;iostream&gt;#include&lt;complex&gt;using namespace std;void ThisTest::func1(int a, int b)&#123; cout &lt;&lt; this &lt;&lt; endl; cout &lt;&lt; this-&gt;a &lt;&lt; endl; this-&gt;a = a;//同名用this cout &lt;&lt; this-&gt;a &lt;&lt; endl; a = b; cout &lt;&lt; a &lt;&lt; endl; cout &lt;&lt; (*this).a &lt;&lt; endl;&#125;void ThisTest::func2()&#123; //cout &lt;&lt; this-&gt;a &lt;&lt; endl;//错误：this只能作用与非静态成员函数的内部&#125;","categories":[{"name":"C/C++","slug":"C-C","permalink":"https://www.liuchanggeng.xyz/categories/C-C/"}],"tags":[{"name":"学习笔记","slug":"学习笔记","permalink":"https://www.liuchanggeng.xyz/tags/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"}]},{"title":"extern","slug":"CPP-Notes/externC","date":"2020-07-25T02:09:00.000Z","updated":"2020-11-16T09:17:23.230Z","comments":true,"path":"2020/07/25/CPP-Notes/externC/","link":"","permalink":"https://www.liuchanggeng.xyz/2020/07/25/CPP-Notes/externC/","excerpt":"","text":"extern 12345678910111213141516//h文件#ifndef EXTERNC_TEST_H#define EXTERNC_TEST_H#ifdef __cplusplusextern &quot;C&quot; &#123;#endif // __cplusplusint func1(int x, int y);int func2();#ifdef __cplusplus&#125;#endif // __cplusplusint func3();#endif // !EXTERNC_TEST_H 123456789101112131415161718//C文件#include&quot;externC_test.h&quot;int func1(int x,int y)&#123; return x + y;&#125;int func2()&#123; return 2;&#125;int func3()&#123; return 3;&#125; 1234567//cpp文件int main()&#123; cout &lt;&lt; func1(1,2) &lt;&lt; endl; cout &lt;&lt; func2() &lt;&lt; endl; // cout &lt;&lt; func3() &lt;&lt; endl;//错误 return 0; 如果运行func3(): 1234567891&gt;------ 已启动生成: 项目: test, 配置: Debug Win32 ------1&gt;main.cpp1&gt;Debug\\static_test.obj : warning LNK4042: 对象被多次指定；已忽略多余的指定1&gt;Debug\\this_test.obj : warning LNK4042: 对象被多次指定；已忽略多余的指定1&gt;main.obj : error LNK2019: 无法解析的外部符号 &quot;int __cdecl func3(void)&quot; (?func3@@YAHXZ)，函数 _main 中引用了该符号1&gt; 已定义且可能匹配的符号上的提示:1&gt; &quot;public: void __thiscall StaticTest::func3(void)&quot; (?func3@StaticTest@@QAEXXZ)1&gt; _func31&gt;F:\\Cpptest\\test\\Debug\\test.exe : fatal error LNK1120: 1 个无法解析的外部命令","categories":[{"name":"C/C++","slug":"C-C","permalink":"https://www.liuchanggeng.xyz/categories/C-C/"}],"tags":[{"name":"学习笔记","slug":"学习笔记","permalink":"https://www.liuchanggeng.xyz/tags/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"}]},{"title":"大小端","slug":"CPP-Notes/大小端","date":"2020-07-25T02:09:00.000Z","updated":"2020-11-16T09:11:49.997Z","comments":true,"path":"2020/07/25/CPP-Notes/大小端/","link":"","permalink":"https://www.liuchanggeng.xyz/2020/07/25/CPP-Notes/%E5%A4%A7%E5%B0%8F%E7%AB%AF/","excerpt":"","text":"大小端 参考资料 百度百科：大小端模式 12345678910int v = 0x12345678;char *ch=new char[4];ch = (char*)&amp;v;for (int i = 0; i &lt; 4; i++)&#123; printf(&quot;%x &quot;,&amp;ch[i]); printf(&quot;%x\\n&quot;,ch[i]);&#125;return 0; 123455cfb84 785cfb85 565cfb86 345cfb87 12&#x2F;&#x2F;高位高地址，地位低地址，即小端模式","categories":[{"name":"C/C++","slug":"C-C","permalink":"https://www.liuchanggeng.xyz/categories/C-C/"}],"tags":[{"name":"学习笔记","slug":"学习笔记","permalink":"https://www.liuchanggeng.xyz/tags/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"}]},{"title":"static关键字","slug":"CPP-Notes/static关键字","date":"2020-07-24T07:57:00.000Z","updated":"2020-11-16T09:18:03.747Z","comments":true,"path":"2020/07/24/CPP-Notes/static关键字/","link":"","permalink":"https://www.liuchanggeng.xyz/2020/07/24/CPP-Notes/static%E5%85%B3%E9%94%AE%E5%AD%97/","excerpt":"","text":"static关键字 参考 C/C++ 中 static 的用法全局变量与局部变量 static 的引入 在函数内部定义的变量，当程序执行到它的定义处时，编译器为它在栈上分配空间，函数在栈上分配的空间在此函数执行结束时会释放掉，这样就产生了一个问题: 如果想将函数中此变量的值保存至下一次调用时，如何实现？ 最容易想到的方法是定义为全局的变量，但定义一个全局变量有许多缺点，最明显的缺点是破坏了此变量的访问范围（使得在此函数中定义的变量，不仅仅只受此函数控制）。static 关键字则可以很好的解决这个问题。 另外，在 C++ 中，需要一个数据对象为整个类而非某个对象服务,同时又力求不破坏类的封装性,即要求此成员隐藏在类的内部，对外不可见时，可将其定义为静态数据。 C++中作用 （1）在修饰变量的时候，static 修饰的静态局部变量只执行初始化一次，而且延长了局部变量的生命周期，直到程序运行结束以后才释放。 （2）static 修饰全局变量的时候，这个全局变量只能在本文件中访问，不能在其它文件中访问，即便是 extern 外部声明也不可以。 （3）static 修饰一个函数，则这个函数的只能在本文件中调用，不能被其他文件调用。static 修饰的变量存放在全局数据区的静态变量区，包括全局静态变量和局部静态变量，都在全局数据区分配内存。初始化的时候自动初始化为 0。 （4）不想被释放的时候，可以使用static修饰。比如修饰函数中存放在栈空间的数组。如果不想让这个数组在函数调用结束释放可以使用 static 修饰。 （5）考虑到数据安全性（当程序想要使用全局变量的时候应该先考虑使用 static）。 全局变量和全局静态变量的区别 1）全局变量是不显式用 static 修饰的全局变量，全局变量默认是有外部链接性的，作用域是整个工程，在一个文件内定义的全局变量，在另一个文件中，通过 extern 全局变量名的声明，就可以使用全局变量。 2）全局静态变量是显式用 static 修饰的全局变量，作用域是声明此变量所在的文件，其他的文件即使用 extern 声明也不能使用。 静态局部变量有以下特点： （1）该变量在全局数据区分配内存； （2）静态局部变量在程序执行到该对象的声明处时被首次初始化，即以后的函数调用不再进行初始化； （3）静态局部变量一般在声明处初始化，如果没有显式初始化，会被程序自动初始化为 0； （4）它始终驻留在全局数据区，直到程序运行结束。但其作用域为局部作用域，当定义它的函数或语句块结束时，其作用域随之结束。 12345678910111213141516171819202122232425262728293031#include &quot;static_test.h&quot;#include &lt;iostream&gt;using namespace std;int StaticTest::a = 0;//必须初始化int StaticTest::c = 0;//必须初始化void StaticTest::func1(void)&#123; cout&lt;&lt;&quot;func1 a: &quot; &lt;&lt; a++ &lt;&lt; endl; cout&lt;&lt;&quot;func1 b: &quot; &lt;&lt; b++ &lt;&lt; endl; cout&lt;&lt;&quot;func1 c: &quot; &lt;&lt; c++ &lt;&lt; endl; cout &lt;&lt; &quot;func1-&gt;&quot;; func2();//类的非静态成员函数可以调用用静态成员函数，但反之不能。&#125;void StaticTest::func2(void)&#123; cout &lt;&lt; &quot;func2 a: &quot; &lt;&lt; a++ &lt;&lt; endl; //cout &lt;&lt; &quot;func2 b: &quot; &lt;&lt; b++ &lt;&lt; endl;//static修饰的函数不能访问非static变量 //cout &lt;&lt; &quot;func2 c: &quot; &lt;&lt; c++ &lt;&lt; endl;//static修饰的函数不能访问非static变量 //fun1();///类的非静态成员函数可以调用用静态成员函数，但反之不能。&#125;void StaticTest::func3(void)&#123; int aa = 0; static int bb = 0; cout &lt;&lt; &quot;func3 aa : &quot; &lt;&lt; aa++ &lt;&lt; endl; cout &lt;&lt; &quot;func3 bb : &quot; &lt;&lt; bb++ &lt;&lt; endl;&#125; 1234567891011121314151617181920#ifndef STATIC_TEST_H#define STATIC_TEST_Hclass StaticTest&#123;public: StaticTest() :/*a(0),//错误*/b(0) &#123; &#125; void func1(void); static void func2(void); void func3(void); static int c;private: static int a; int b;&#125;;#endif // !STATIC_TEST_H 12345678910111213141516171819#include&quot;static_test.h&quot;int main()&#123; StaticTest ST; ST.func1(); ST.func1(); ST.func1(); //ST.c = 1;//错误，文件外不能访问 //StaticTest::c = 1;//错误，文件外不能访问 ST.func2(); ST.func2(); ST.func2(); ST.func3(); ST.func3(); ST.func3(); // StaticTest::func1();//错误，不能通过类名来调用类的非静态成员函数。类的对象可以使用静态成员函数和非静态成员函数 StaticTest::func2(); return 0;&#125; 静态成员函数 （1）静态成员函数和静态数据成员一样，他们都属于类的静态成员，而不是对象成员。 （2）非静态成员函数有 this 指针，而静态成员函数没有 this 指针。 （3）静态成员函数主要用来方位静态数据成员而不能访问非静态成员。","categories":[{"name":"C/C++","slug":"C-C","permalink":"https://www.liuchanggeng.xyz/categories/C-C/"}],"tags":[{"name":"学习笔记","slug":"学习笔记","permalink":"https://www.liuchanggeng.xyz/tags/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"}]},{"title":"C++ 内存模型","slug":"CPP-Notes/C++内存模型","date":"2020-07-24T07:09:00.000Z","updated":"2020-11-16T09:04:59.272Z","comments":true,"path":"2020/07/24/CPP-Notes/C++内存模型/","link":"","permalink":"https://www.liuchanggeng.xyz/2020/07/24/CPP-Notes/C++%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B/","excerpt":"","text":"C++ 内存模型 参考资料 C/C++程序内存的分配 深入理解计算机系统 一个C/C++编译的程序占用内存分为以下几个部分： 栈区（stack）：由编译器自动分配与释放，存放为运行时函数分配的局部变量、函数参数、返回数据、返回地址等。其操作类似于数据结构中的栈。 堆区（heap）：一般由程序员自动分配，如果程序员没有释放，程序结束时可能有OS回收。其分配类似于链表。 全局区（静态区static）：存放全局变量、静态数据、常量。程序结束后由系统释放。全局区分为已初始化全局区（data）和未初始化全局区（bss）。 常量区（文字常量区）：存放常量字符串，程序结束后有系统释放。 代码区：存放函数体（类成员函数和全局区）的二进制代码。 三种内存分配方式 从静态存储区分配 ：内存在程序编译的时候已经分配好，这块内存在程序的整个运行期间都存在。例如全局变量，static变量。 在栈上创建： 在执行函数时，函数内局部变量的存储单元可以在栈上创建，函数执行结束时，这些内存单元会自动被释放。栈内存分配运算内置于处理器的指令集，效率高，但是分配的内存容量有限。 从堆上分配：亦称为动态内存分配。程序在运行的时候使用malloc或者new申请任意多少的内存，程序员自己负责在何时用free或delete释放内存。 动态内存的生命周期有程序员决定，使用非常灵活，但如果在堆上分配了空间，既有责任回收它，否则运行的程序会出现内存泄漏，频繁的分配和释放不同大小的堆空间将会产生内存碎片。 简图 在 C 语言中，全局变量又分为初始化的和未初始化的（未被初始化的对象存储区可以通过 void* 来访问和操纵，程序结束后由系统自行释放），在 C++ 里面没有这个区分了，他们共同占用同一块内存区。 管理方式不同：栈是由编译器自动申请和释放空间，堆是需要程序员手动申请和释放； 空间大小不同：栈的空间是有限的，在32位平台下，VC6下默认为1M，堆最大可以到4G； 能否产生碎片：栈和数据结构中的栈原理相同，在弹出一个元素之前，上一个已经弹出了，不会产生碎片，如果不停地调用malloc、free对造成内存碎片很多； 生长方向不同：堆生长方向是向上的，也就是向着内存地址增加的方向，栈刚好相反，向着内存减小的方向生长。 分配方式不同：堆都是动态分配的，没有静态分配的堆。栈有静态分配和动态分配。静态分配是编译器完成的，比如局部变量的分配。动态分配由 malloc 函数进行分配，但是栈的动态分配和堆是不同的，它的动态分配是由编译器进行释放，无需我们手工实现。 分配效率不同：栈的效率比堆高很多。栈是机器系统提供的数据结构，计算机在底层提供栈的支持，分配专门的寄存器来存放栈的地址，压栈出栈都有相应的指令，因此比较快。堆是由库函数提供的，机制很复杂，库函数会按照一定的算法进行搜索内存，因此比较慢。 64位Ubnutu下测试 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647#include&lt;stdio.h&gt;#include&lt;stdlib.h&gt;#include&lt;iostream&gt;using namespace std;void test()&#123; int i=0; cout&lt;&lt;&quot;func() int: &quot;&lt;&lt;&amp;i&lt;&lt;endl; int *j=new int; cout&lt;&lt;&quot;func() new int: &quot;&lt;&lt;j&lt;&lt;endl; delete j;&#125;int global=10;int *gp=new int;int main()&#123; int s=sizeof(int); int s1=sizeof(long); printf(&quot;%d\\n&quot;,s); printf(&quot;%d\\n&quot;,s1); printf(&quot;hello\\n&quot;); int i=0; int *j=new int; int *k=new int; int *ii=&amp;i; int *iii=new int; iii=&amp;i; int *a=(int*)malloc(sizeof(int)*10); int *p=NULL; const static int x=1; cout&lt;&lt;&quot;&amp; int: &quot;&lt;&lt;&amp;i&lt;&lt;endl; cout&lt;&lt;&quot;new int: &quot;&lt;&lt;j&lt;&lt;endl; cout&lt;&lt;&quot;new int: &quot;&lt;&lt;k&lt;&lt;endl; cout&lt;&lt;&quot;malloc int: &quot;&lt;&lt;a&lt;&lt;endl; cout&lt;&lt;&quot;int*: &quot;&lt;&lt;p&lt;&lt;endl; cout&lt;&lt;&quot;int*=&amp;int: &quot;&lt;&lt;ii&lt;&lt;endl; cout&lt;&lt;&quot;new int*=&amp;int: &quot;&lt;&lt;iii&lt;&lt;endl; cout&lt;&lt;&quot;const static int :&quot;&lt;&lt;&amp;x&lt;&lt;endl; cout&lt;&lt;&quot;global int&quot;&lt;&lt;&amp;global&lt;&lt;endl; cout&lt;&lt;&quot;global new int*&quot;&lt;&lt;gp&lt;&lt;endl; test(); delete j; delete k; free(a); delete gp; return 0;&#125; 1234567891011121314151648hello&amp; int: 0x7ffff146db8cnew int: 0x1156050new int: 0x1156070malloc int: 0x11560b0int*: 0int*&#x3D;&amp;int: 0x7ffff146db8cnew int*&#x3D;&amp;int: 0x7ffff146db8cconst static int :0x400fd4global int0x6020a0global new int*0x1155c20func() int: 0x7ffff146db5cfunc() new int: 0x11560e0 windows下测试结果不同 参考堆、栈的地址高低？ 栈的增长方向？ - RednaxelaFX的回答 - 知乎","categories":[{"name":"C/C++","slug":"C-C","permalink":"https://www.liuchanggeng.xyz/categories/C-C/"}],"tags":[{"name":"学习笔记","slug":"学习笔记","permalink":"https://www.liuchanggeng.xyz/tags/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"}]},{"title":"35个改善编程与设计的有效方法","slug":"CPP-Notes/35个改善编程与设计的有效方法","date":"2020-07-04T11:48:00.000Z","updated":"2020-11-16T09:07:00.478Z","comments":true,"path":"2020/07/04/CPP-Notes/35个改善编程与设计的有效方法/","link":"","permalink":"https://www.liuchanggeng.xyz/2020/07/04/CPP-Notes/35%E4%B8%AA%E6%94%B9%E5%96%84%E7%BC%96%E7%A8%8B%E4%B8%8E%E8%AE%BE%E8%AE%A1%E7%9A%84%E6%9C%89%E6%95%88%E6%96%B9%E6%B3%95/","excerpt":"","text":"35个改善编程与设计的有效方法 基础议题 条款1：仔细区别pointers和references reference: 一定要代表某个对象，所以必须有初值。 比pointers可能更有效率，因为在使用reference之前不需要测试其有效性。 初始化后不可更改 不存在reference的reference，因为其只作用于对象。 pointers： 可以初值为null。 使用前判断它是否为null 可以重新赋值，指向另一个对象 结论 当你知道你需要指向某个东西，而且绝不会改变指向其他东西，或是当你实现一个操作符而其语法需求无法有pointers达成，就应该选择references。其他情况，请使用pointers。","categories":[{"name":"C/C++","slug":"C-C","permalink":"https://www.liuchanggeng.xyz/categories/C-C/"}],"tags":[{"name":"学习笔记","slug":"学习笔记","permalink":"https://www.liuchanggeng.xyz/tags/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"}]},{"title":"改善程序与设计的55个具体做法","slug":"CPP-Notes/改善程序与设计的55个具体做法","date":"2020-07-04T11:48:00.000Z","updated":"2020-11-16T09:04:53.028Z","comments":true,"path":"2020/07/04/CPP-Notes/改善程序与设计的55个具体做法/","link":"","permalink":"https://www.liuchanggeng.xyz/2020/07/04/CPP-Notes/%E6%94%B9%E5%96%84%E7%A8%8B%E5%BA%8F%E4%B8%8E%E8%AE%BE%E8%AE%A1%E7%9A%8455%E4%B8%AA%E5%85%B7%E4%BD%93%E5%81%9A%E6%B3%95/","excerpt":"","text":"改善程序与设计的55个具体做法 让自己习惯C++ 条款1：视C++为一个语言联邦 今天的C已经是一个多重编程范型语言，一个同时支持过程形式，面向对象形式，泛型形式，元编程形式的语言。 可以把C视为一个有相关语言组成的联邦而非单一语言，C++的次语言一共有四种： C Object-Oriented C++: 类，封装，继承，多态，虚函数… Template C++ ：泛型编程 STL：STL是一个Template程序库。 pass-by-value,pass-by-reference-to-const C高效编程守则取决于你使用C的那一部分。 条款2：尽量以const，enum，inline替换 #define const 宁可以编译器替换预处理器。 1#define ABC 1 可能编译器在处理源码前ABC就被预处理器移走了，可以理解把程序中的ABC都替换为1，会导致ABC这个名称没有进入记号表(symbol table)，编译一旦出错，错误信息不会显示ABC，只会是1. 解决方法 1const int abc=1;//一般宏大写 使用常量不会像宏一样替换代码，所以“码量”较小。 12const char* const authorName=&quot;Scott Meyers&quot;;const std::string authorName(&quot;Scott Meyers&quot;);//这样定义比上面好 如果是类的专属常量，就要在类中声明一个常量成员;为了确保此常量至多有一份实体，必须让他成为一个static成员 123456class GamePlayer&#123;private: static const int NumTurns=5;//常量声明式,不是定义式 int scores[NumTurns];&#125;; 旧的编译器不允许static成员在声明式获得初值，所以需要在定义式给初值。 class的专属常量如果是static 整数类型(int、char、bool)，就不需要提供定义式。但若要取这个常量的地址或编译器(错误的)坚持看到一个定义式，则需要在实现文件中提供定义： 1const int GamePlayer::NumTurns;//在声明时获得初值，这里不能再设置初值 #define相当于替换代码，所以不能用来定义class的专属常量，也不能提供封装性。 enum 外一编译器(错误的)不允许初值设定，这样编译器在编译期间也无法知道数组大小，可以用&quot;the enum hack&quot;解决 123456class GamePlayer&#123;private: enum &#123;NumTurns=5;&#125; int scores[NumTurns];&#125;; 取const的地址合法，而enum不合法(和#define比较像),所以也不会导致非必要的内存分配。 实用主义：许多代码这样使用enum，属于模板元编程基础技术。 inline 一般调用宏实现像函数的宏，需要为所有实参加上小括号。 1#define CALL_WITH_MAX(a,b) f((a)&gt;(b)?(a):(b)) 但即使是这样也会造成意想不到的结果 123int a=5,b=0;CALL_WITH_MAX(a,b);//a累加2次CALL_WITH_MAX(a,b+10);//a累加一次 为了获得宏带来的效率并且类型安全性考虑。使用template inline替代宏 12345template&lt;typename T&gt;inline void callWithMax(const T&amp;a,constT&amp; b)&#123; f(a&gt;b?a:b);&#125; 总结： 对于单纯常量，最好以const对象或enum替代#define 对于形似函数的宏(macros)，最好改为inline函数替代#define 条款3：尽可能使用const const出现在*号左边，表示被指物(data)是常量。*号右边表示指针(pointer)自身是常量。 12345char greeting[]=&quot;Hello&quot;;char *p=greeting;const char* p=greeting;char* const p=greeting;const char* const p=greeting; 在函数调用中： 12void f1(const int *a);void f2(int const *a); 两种写法等效，表示函数获得一个指针，指向常量的int对象。注意*的位置。 关于迭代器const： STL迭代器是以指针为根据塑模出来，所以迭代器的作用就像个T*指针。 12345678std::vector&lt;int&gt; vec;...const std::vector&lt;int&gt;::iterator iter=vec.begin();//T* const*iter=10;//没问题，改变的是iter所指的物++iter;//错误，iter是conststd::vector&lt;int&gt;::iterator const_iterator cIter=vec.begin();//const T**cIter=1; //错误，*cIter是const++cIter; //正确，改变的是cIter 令函数返回一个常量值，往往可以降低因客户错误而造成的意外。 const成员函数 使接口易于理解，知道哪个函数可以改动，哪些不可以改 “操作const对象”，高效编程-&gt;pass by reference-to-const(有const成员函数才能这么传递对象) 语法：在成员函数的参数列表后面加上const关键字。 bitwise constness(physical constness)阵营:成员函数只有在不更改对像任何成员变量时才可以是const成员函数，否则编译出错。 但是有时成员函数不具备const性质却也可以通过bitwise测试，如更改指针所指物 logical constness:const成员函数可以修改它所处理的对象内的某些bits，但只有在客户端检测不出的情况下才得如此。 使用mutable(可变的)关键字 修饰成员变量，使其在const成员函数内也可以被修改。 const和non-const成员函数中避免重复 两个相同的函数，但一个是const，一个是non-const，这也是重载。但这通常只为了不同的调用方式，const的调用const的，non-const调用non-const的。这会导致相同的代码有两份几乎一摸一样的，很难维护。 解决办法:在const中实现，non-const的函数调用const的。为了避免non- const函数无穷递归自己。需要利用转型。static_cast将*this从non-const转成const，之后再用const_cast将const移除。 总结 将默写东西声明为const可帮助编译器侦测出错误用法，const可被施加于任何作用域内的对象、函数参数、返回类型、成员函数本体。 编译器强制实施bitwise constness，但你编写程序时应该使用“概念性的常量性” 当const和non-const成员函数有实质性等价的实现时，令non-const版本调用const可避免代码重复 条款4：确定对象被使用前已先被初始化 永远在使用对象之前先将他初始化。 对于无任何成员的内置类型，需要手工完成此事。 对于内置类型之外的任何其他东西，初始化责任落在构造函数身上。要确保每个构造函数都将对象的每一个成员初始化。 注意赋值和初始化的区别。即使在构造函数中赋值，也不算初始化。 12345678910111213class A&#123;public: A(const std::string&amp; name);private: std::string theName; int n;&#125;A::A(const std::string&amp; name)&#123; theName=name;//这是赋值，非初始化 n=0;&#125; 初始化应该写成(效率较高)： 1234A::A(const std::string&amp; name)：theName(name),n(0)&#123;&#125;//构造函数本体无任何动作 C++规定，对象的成员变量的初始化动作发生在构造函数本体之前，发生于这些成员的default构造函数被自动调用之时。但对内置类型int不为真，不保证你所看到的那个赋值动作的时间点之前获得初值。 基于赋值的那个版本首先调用default构造函数为theName设初值，然后立刻再对他们赋予新值。default构造函数的一切作为因此浪费了。避免浪费的做法是第二种，成员初值列。theName以name为初值进行copy构造。 对于内置烈类型，其初始化和赋值成本相同，但为了一致性，一般也通过成员初值列来初始化。 初始化顺序 C++有十分固定的成员初始化顺序。 先基类后子类。 声明顺序而非成员初值列顺序。 不同编译单元内定义之non-local static 对象 的初始化顺序。 编译单元：当一个c或cpp文件在编译时，预处理器首先递归包含头文件，形成一个含有所有必要信息的单个源文件，这个源文件就是一个编译单元。 static对象：寿命从被构造出来直到程序结束为止，因此stack和heap-based对象都被排除。 local-static对象：函数内的static对象称为local static对象，因为他们对函数而言是local的。 non-local static对象：非local 的static对象都是non-local对象 问题：C++对“定义于不同编译单元的non-local对象”的初始化并无明确定义。 如果两个不同编译单元的non-local static对象其中一个需要另一个先出现，但是编译器无法做到。 解决办法：将每个non-local static 对象搬到自己的专属函数内，该对象在此函数内被声明为static，这些函数返回一个reference指向它所含的对象。然后用户调用这些函数，而不直接涉及这些对象。也就是，non-local static被local static 对象替换了。这是Singleton模式的一个常见实现手法。 结论 为内置型对象手工初始化，因为C++不保证初始化他们。 构造函数最好使用成员初值列，而不要在构造函数本体内使用赋值操作，初值列列出的成员变量，其排列次序应该和他们在class中的声明次序相同。 为免除“跨编译单元之初始化次序”问题请以local static对象替换non-local static对象。 构造/析构/赋值运算 条款05 了解C++默默编写并调用了哪些函数 如果没有声明构造函数，编译器可以暗自为class创建default构造函数、copy构造函数、copy assignment操作符，以及析构函数。 1234class Empty&#123;&#125; 当被调用时会创建出以下代码: 12345678910class Empty&#123;public: Empty()&#123;...&#125; Empty (const Empty&amp; rhs)&#123;...&#125; ~Empty()&#123;...&#125; Empty&amp; operator=(const Rmpty&amp; rhs)&#123;...&#125;//copy assignment&#125; 当程序中这些函数被调用是，编译器自动创建出来。 1234Empty e1; //default 构造函数Empty e2=e1;//copy 构造函数Empty e2(e1);//copy 构造函数e2=e1;//copy assignment操作符 但时有时也无法自动创建，如类的成员变量中存在const或reference时： 12345...private: const a; std::string&amp; s;... C++不允许绕让reference改变所指向的对象 更改const成员是不合法的。 所以编译器不能够创建这种copy assignment。需要自己定义copy assignment。 另外，父类的copy assignment的若是private的，子类不会自动生成copy assignment。 条款06 若不想使用编译器自动生成的函数，就应该明确拒绝 有时候我们不希望类有拷贝构造功能，但编译器通常会自己生成这些函数。 解决思路:编译器产出的函数都是public的，所以为阻止编译器创建，可以将copy构造函数或copy assignment操作符声明为private。 但这样并不绝对安全，因为成员函数和友元函数仍可以调用它，这时我们不能定义它们，当有人调用时，会获得一个连接错误(linkage error)。 C标准库中如ios_base的copy构造函数和copy assignment操作符都是private的而且没有定义。 (注：C11引入了新的特性 =delete,比上述private:更高效。private报错时可能很复杂，而=delete会提示这个方法已被删除) 123public: ios_base(const ios_base&amp;) = delete; ios_base&amp; operator=(const ios_base&amp;) = delete; 另外可以设计一个阻止copying的基类，其他子类继承他。 条款07：为多态基类声明virtual析构函数","categories":[{"name":"C/C++","slug":"C-C","permalink":"https://www.liuchanggeng.xyz/categories/C-C/"}],"tags":[{"name":"学习笔记","slug":"学习笔记","permalink":"https://www.liuchanggeng.xyz/tags/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"}]},{"title":"侯捷-C++面向对象高级开发笔记","slug":"CPP-Notes/note1","date":"2020-07-03T01:04:00.000Z","updated":"2020-11-16T09:05:08.656Z","comments":true,"path":"2020/07/03/CPP-Notes/note1/","link":"","permalink":"https://www.liuchanggeng.xyz/2020/07/03/CPP-Notes/note1/","excerpt":"","text":"简介 此文档为本人边看视频边记的笔记，方便以后自己回看笔记时能快速想起课程内容，详细内容请看老师讲的视频。 课程来源:GeekBand,也可以在b站搜到. 如果不能显示出图，请看Github的博文。 C++ 编程简介 基于对象(Object Based) class without pointer members -Complex class with pointer members -String 面向对象(Object Oriented) 学习Classes之间的关系 继承(inheritance) 复合(composition) 委托(delegation) C++历史 C语言(1972) C++(1983)早期叫C with Class C有很多版本,如 C98,C03,C 11,C++14 学习C++(其他语言也是)可以分为两个部分： C++语言 C++标准库 经典的书： C++ Primer (C++第一个编译器的作者写的) C++ Programming Language (C++之父写的) Effective C++ (专家写的，以条款方式写的) The C++ Standard Library(写的C++的标准库) STL源码剖析(较深入的将标准库) 头文件与类的声明 C vs C++ C语言数据和函数是分离的，数据都是全局的。这样编程有很大影响。后来发展的C是数据和函数合在一起成为class，C的struct几乎等同于class,只有微小的差别。 前面讲过的class可以分为带指针和不带指针的，典型的例子就是complex(不带指针)和string(带指针) Object Based : 面对的是单一class 的设计 Object Oriented : 面对的是多重classes 的设计，classes 和classes 之间的关系。 C++的代码基本形式 注意头文件：&lt;&gt;对应标准库，“”对应自己写的东西 头文件中的防卫式声明(guard) 1234#ifndef __COMPLEX__#define __COMPLEX__...#endif 可以避免包含头文件时的顺序问题。 头文件的布局 12345678910111213141516#ifndef __COMPLEX__#define __COMPLEX__// forward declarations：前置声明#include &lt;cmath&gt;class ostream;class complex;complex&amp;__doapl (complex* ths, const complex&amp; r);// 类：声明class complex&#123; ...&#125;;//类：定义complex::function ...#endif class的声明 123456789101112131415class complex//class head&#123; //class body //有些函數在此直接定义，另一些在body 之外定义public: complex (double r = 0, double i = 0) : re (r), im (i) &#123; &#125; complex&amp; operator += (const complex&amp;);//声明 double real () const &#123; return re; &#125; double imag () const &#123; return im; &#125;private: double re, im; friend complex&amp; __doapl (complex*, const complex&amp;);&#125;; 使用时 12345&#123; complex c1(2,1); complex c2; ...&#125; 上述代码中复数只有double的实部和虚部，为了可以支持多种类型并且不增加类，我们引入模板。 1234567891011121314template&lt;typename T&gt;//T也可以是其他字母class complex&#123; public: complex (T r = 0, T i = 0) : re (r), im (i) &#123; &#125; complex&amp; operator += (const complex&amp;); T real () const &#123; return re; &#125; T imag () const &#123; return im; &#125;private: T re, im; friend complex&amp; __doapl (complex*, const complex&amp;);&#125;; 使用时: 12345&#123; complex&lt;double&gt; c1(2.5,1.5);//T指定为double complex&lt;int&gt; c2(2,6);//T指定为int ...&#125; 内联函数、访问级别、构造函数 inline(内联)函数 1234567891011121314class complex&#123; public: complex (double r = 0, double i = 0) : re (r), im (i) &#123; &#125; complex&amp; operator += (const complex&amp;); double real () const &#123; return re; &#125; double imag () const &#123; return im; &#125;private: double re, im; friend complex&amp; __doapl (complex*, const complex&amp;);&#125;; 函数在class本体里定义就形成了inline，inline像宏一样，函数如果是inline的，就会很快，所以所有的函数都写成inline是最好的，然而编译器没有能力把所有函数都做成inline，一般来说程序复杂，编译器就不能做成inline。inline function最后能不能做成inline看编译器的能力。 不在本体里定义inline的要加inline： 12345inline doubleimag(const complex&amp; x)&#123; return x.imag ();&#125; 访问级别(access level) public ：外部能看到的 private：只有自己能看到的，一般只有内部函数处理的数据要用private protect：受保护的 错误示范： 12345&#123; complex c1(2,1); cout &lt;&lt; c1.re; cout &lt;&lt; c1.im;&#125; 正确示范： 12345&#123; complex c1(2,1); cout &lt;&lt; c1.real(); cout &lt;&lt; c1.imag();&#125; 构造函数(construct，ctor) 如果创建一个对象，构造函数会自动调用起来。没有程序里直接调用函数的写法。 如以下三种方法创建对象： 12345&#123; complex c1(2,1); complex c2; complex* p = new complex(4);&#125; 则会自动调用之前写的代码： 123complex (double r = 0, double i = 0)//0为默认实参(default argument) : re (r), im (i)//初值列，初始列，initialization list&#123; &#125; 构造函数的写法很独特，他的函数名称一定要和类的名称相同。 构造函数没有返回值类型，因为不需要有，因为构造函数就是要创建类的。 注意默认值并不是构造函数特性，其他函数也可以写成默认值。 initialization list是只有构造函数才有的写法。 如上面的代码也可以写成： 12complex (double r = 0, double i = 0)&#123; re = r; im = i; &#125;//赋值 两种写法结果是一样的，但是一般有过良好编程习惯的会写成第一种。 第一种效率会好一些，背后有很多原理，简单来讲可以说是因为变量数值的设定有两个阶段，一个是初始化，一个是赋值。第二种写法就是跳过了初始化，效果差。 相对于构造函数有一个析构函数，不带指针的类多半不用写析构函数，如上述所写的Complex。 重载 overloading 构造函数可以有很多个重载。 重载：同名的函数名称有很多个以上。重载常常发生在构造函数身上。 图中的两个构造函数是不能同时存在的，因为在创建对象时，无法知道应该调用哪个构造函数。 同名的函数在编译器处理后会变成其他名字。这个名字是给机器看的。编译器会把函数的名称，参数有几个，参数是什么类型编码，机器会区分出同名的不同函数。 构造函数也可以放在private里，这是不能按照之前的方法创建对象。详细的使用方法这里先不讲。但要知道有这种写法。 如设计模式Singleton： 1234567891011121314class A &#123;public: static A&amp; getInstance(); setup() &#123; ... &#125;private: A(); A(const A&amp; rhs); ...&#125;;A&amp; A::getInstance()&#123; static A a; return a;&#125; 1A::getInstance().setup(); 参数传递与返回 定义函数是确定是否添加const 12345678910111213 class complex&#123; public: complex (double r = 0, double i = 0) : re (r), im (i) &#123; &#125; complex&amp; operator += (const complex&amp;); double real () const &#123; return re; &#125; double imag () const &#123; return im; &#125;private: double re, im; friend complex&amp; __doapl (complex*, const complex&amp;);&#125;; 注意 1double real () const &#123; return re; &#125; 函数中的const是十分重要的，很多人会忽略。 const在此处的表示函数只是将数据取出，并不改变数据内容。 class的函数可以分为会改变函数内容的和不会改变函数内容的。不会改变数据内容的函数要加加const。 开发人员在设计接口时就要确定是否要加const。 如果不加会产生什么后果： 12345 &#123; const complex c1(2,1); cout &lt;&lt; c1.real(); cout &lt;&lt; c1.imag();&#125; 上面的const说明使用者复数中的2，1是不能变的，假如定义时不加const，说明这个函数可能会改数据，这样在定义和调用就发生了冲突。 参数传递(pass by value vs. pass by reference(to const)) 12345678910111213class complex&#123; public: complex (double r = 0, double i = 0) : re (r), im (i) &#123; &#125; complex&amp; operator += (const complex&amp;);//pass by reference double real () const &#123; return re; &#125; double imag () const &#123; return im; &#125;private: double re, im; friend complex&amp; __doapl (complex*, const complex&amp;);&#125;; by value :是数据整包传过去，数据有几个字节就传几个字节 by reference(引用)：带&amp;,传引用相当与传指针的速度。 by reference(to const):没有const时，传给对方的数据，对方可能修改后影响我，如果不想自己受到影响，就要加上const，表示此引用不会该改变数据，对方改变就会出错。 良好的习惯：参数传递尽量的传引用，速度快 返回值传递(return by value vs. return by reference(to const)) 上述代码中 12complex&amp; operator += (const complex&amp;);//return by referencedouble real () const &#123; return re; &#125;//return by value 友元 friend 1234567inline complex&amp;__doapl (complex* ths, const complex&amp; r)&#123; ths-&gt;re += r.re;//自由取得friend 的private成员。 ths-&gt;im += r.im; return *ths;&#125; 相同class的各个object互为friends 使用场景 看下面的例子do assignment plus(__doapl) 123456789101112inline complex&amp;__doapl(complex* ths, const complex&amp; r)&#123; ths-&gt;re += r.re; ths-&gt;im += r.im; return *ths;&#125;inline complex&amp;complex::operator += (const complex&amp; r)&#123; return __doapl (this, r);&#125; 上述代码中的第一个参数(ths)会发生改动,则不能加const，第二个参数®不会发生改动,可以加const。 在函数里面创建的东西不能加引用往外传，因为那是局部的，传到外面就消失了，其他情况都可以传引用(inline complex&amp;)。 操作符重载(operator overloading) C++中操作符其实就是一种函数，也可以重载。 成员函数重载 所有的成员函数都带有一个隐藏的参数(this)，谁调用，谁就是this。this是一个指针，下面是一个复数+=运算的例子。 传递者无需知道接收者是以reference形式接收,上述代码中编写 return *ths;时不必考虑返回的是以什么形式接收的。 此外，complex::operator +=的返回 complex&amp;，也可以返回void，这时执行，c2+=c1没有问题，但是如果连续赋值c3+=c2+=c1;就会有问题，所以严谨写法为返回complex&amp;。 非成员函数重载(无this) 12345678910111213141516inline complexoperator + (const complex&amp; x, const complex&amp; y)//复数加复数&#123; return complex (real (x) + real (y), imag (x) + imag (y));&#125;inline complexoperator + (const complex&amp; x, double y)//复数+实数&#123; return complex (real (x) + y, imag (x));&#125;inline complexoperator + (double x, const complex&amp; y)//实数+复数&#123; return complex (x + real (y), imag (y));&#125; 注意上述代码不能return by reference，因为他们的返回必定是local object。 complex()的语法是，temp object(临时对象)， typename(); 1234567#include &lt;iostream.h&gt;ostream&amp;operator &lt;&lt; (ostream&amp; os, const complex&amp; x)&#123; return os &lt;&lt; &#x27;(&#x27; &lt;&lt; real (x) &lt;&lt; &#x27;,&#x27; &lt;&lt; imag (x) &lt;&lt; &#x27;)&#x27;;&#125; cout是一种对象，ostream. 拷贝构造，拷贝复制，析构 Class with pointer member(s)：string 123456789#ifndef __MYSTRING__#define __MYSTRING__class String&#123; ...&#125;;String::function(...) ...Global-function(...) ...#endif 123456789int main()&#123; String s1(), String s2(&quot;hello&quot;); String s3(s1); cout &lt;&lt; s3 &lt;&lt; endl; s3 = s2; cout &lt;&lt; s3 &lt;&lt; endl;&#125; complex等不带指针类的拷贝构造赋值等是编译器给的拷贝构造赋值方式，一位一位的搬过去。 而带指针的类(string)拷贝构造赋值需要自己写，不能按编译器的来。 1234567891011class String&#123;public: String(const char* cstr = 0);//构造函数 String(const String&amp; str);//拷贝构造函数（带自己的String，所以叫拷贝） String&amp; operator=(const String&amp; str);//拷贝赋值 ~String();//析构函数 char* get_c_str() const &#123; return m_data; &#125;//成员函数private: char* m_data;&#125;; 带指针的要写三个特殊函数(Big Three)： 拷贝构造函数 拷贝赋值 析构函数 ctor和dtor(构造函数和析构函数) 123456789101112131415161718inlineString::String(const char* cstr = 0)&#123; if (cstr) &#123; m_data = new char[strlen(cstr)+1]; strcpy(m_data, cstr); &#125; else &#123;// 未指定初值 m_data = new char[1]; *m_data = &#x27;\\0&#x27;;//放结束符号，空 &#125;&#125;inlineString::~String()//析构，清理&#123; delete[] m_data;&#125; 带指针的要写析构函数，因为动态分配内存需要释放，对象死亡的前一刻，要用delete将内存杀掉。 拷贝构造和拷贝赋值 如果不自己编写，编译器做一位一位的拷贝。并且会发生 内存泄漏 。 如，字符串赋值，b=a，赋值后，b原先的内存没有指针指向，造成内存泄漏。同时，a和b内存由相同的指针指向，改a或b会对对方造成影响，很危险。这种叫浅拷贝。 而需要写的是 深拷贝。 拷贝构造函数 123456inlineString::String(const String&amp; str)&#123; m_data = new char[ strlen(str.m_data) + 1 ]; strcpy(m_data, str.m_data);//深拷贝&#125; 12345&#123; String s1(&quot;hello &quot;); String s2(s1); // String s2 = s1;//两种赋值方法相同&#125; 拷贝赋值函数: 左边=右边。 过程：先把左边清空，分配出和右边一样的空间，再把右边拷贝过来。 12345678910inlineString&amp; String::operator=(const String&amp; str)&#123; if (this == &amp;str)//检测自我赋值(self assignment)：检测是不是自己赋值给自己。s1=s1 return *this; delete[] m_data;//第一步 m_data = new char[ strlen(str.m_data) + 1 ];//第二步 strcpy(m_data, str.m_data);//第三步 return *this;&#125; 栈(stack),堆(heap) 本节讲new Stack，是存在于某作用域(scope) 的一块内存空间(memory space)。当你调用函数，函数本身即会形成一个stack 用来放置它所接收的参数，以及返 回地址。 在函数本体(function body) 内声明的任何变量，其所使用的内存块都取自上述stack。 Heap，或者称为system heap，是指由操作系统提供的一块global 内存空间，程序可动态分配(dynamic allocated) 从某中获得若干区块(blocks)。 123456789class Complex &#123; … &#125;;...Complex c3(1,2);&#123; Complex c1(1,2);//c1 所占用的空间來自stack static Complex c2(1,2); Complex* p = new Complex(3);//Complex(3) 是个临时对象，其所占用的空间乃是以new 自heap 动态分配而得，并由p 指向。 delete p;&#125; c1 便是stack object，其生命在作用域(scope) 结束之后结束。这种作用域内的object，又称为auto object，因为它会被「自动」清理。 c2 便是static object，其生命在作用域(scope)结束之后仍然存在，直到整个程序结束。 还有一种是全局对象(global object),c3 便是global object，其生命在整个程序结束之后 才结束。你也可以把它视为一种static object，其作用域是「整个程序」。 p 所指的便是heap object，其生命在它被deleted 之后结束。 如果不加delete，会出現内存泄漏(memory leak)，因为当作用域结束，p 所指的heap object 仍然存在，但指针p 的生命却结束了，作用域之外再也看不到p(也就沒机会delete p）。 C++中分配内存和释放的内部实现是C语言中的malloc，free。 new: 先分配memory，再调用ctor(Complex) delete:先调用dtor，再释放memory(Complex) new: 先分配memory，再调用ctor(String) delete:先调用dtor，再释放memory(String) 动态分配内存块(memory block), in VC 动态分配所得的array 老师讲的很好，看视频。其他教程和书籍一般不讲这些。 概括来说，就是操作系统中实际分配的内存并不是我们平时认为的大小，而是有一些附加内存，并且有调试模式和非调试模式。分配的内存大小要是16的整数倍。小于的话要补上pad(00000000)。 array new 一定要搭配array delete delete[]:表示删除的是数组，编译器会调用多次析构函数。","categories":[{"name":"C/C++","slug":"C-C","permalink":"https://www.liuchanggeng.xyz/categories/C-C/"}],"tags":[{"name":"学习笔记","slug":"学习笔记","permalink":"https://www.liuchanggeng.xyz/tags/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"}]}],"categories":[{"name":"Matlab","slug":"Matlab","permalink":"https://www.liuchanggeng.xyz/categories/Matlab/"},{"name":"STK","slug":"Matlab/STK","permalink":"https://www.liuchanggeng.xyz/categories/Matlab/STK/"},{"name":"Hexo","slug":"Hexo","permalink":"https://www.liuchanggeng.xyz/categories/Hexo/"},{"name":"Matlab","slug":"Hexo/Matlab","permalink":"https://www.liuchanggeng.xyz/categories/Hexo/Matlab/"},{"name":"C/C++","slug":"C-C","permalink":"https://www.liuchanggeng.xyz/categories/C-C/"}],"tags":[{"name":"软件安装入门","slug":"软件安装入门","permalink":"https://www.liuchanggeng.xyz/tags/%E8%BD%AF%E4%BB%B6%E5%AE%89%E8%A3%85%E5%85%A5%E9%97%A8/"},{"name":"建站","slug":"建站","permalink":"https://www.liuchanggeng.xyz/tags/%E5%BB%BA%E7%AB%99/"},{"name":"奇技淫巧","slug":"奇技淫巧","permalink":"https://www.liuchanggeng.xyz/tags/%E5%A5%87%E6%8A%80%E6%B7%AB%E5%B7%A7/"},{"name":"Hexo","slug":"Hexo","permalink":"https://www.liuchanggeng.xyz/tags/Hexo/"},{"name":"学习笔记","slug":"学习笔记","permalink":"https://www.liuchanggeng.xyz/tags/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"}]}