<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Hexo</title>
  
  
  <link href="https://www.liuchanggeng.xyz/atom.xml" rel="self"/>
  
  <link href="https://www.liuchanggeng.xyz/"/>
  <updated>2021-05-10T13:08:52.477Z</updated>
  <id>https://www.liuchanggeng.xyz/</id>
  
  <author>
    <name>LCG</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Matlab安装minGW</title>
    <link href="https://www.liuchanggeng.xyz/2021/05/10/softwareGetStart/Matlab%E5%AE%89%E8%A3%85minGW/"/>
    <id>https://www.liuchanggeng.xyz/2021/05/10/softwareGetStart/Matlab%E5%AE%89%E8%A3%85minGW/</id>
    <published>2021-05-10T10:38:53.000Z</published>
    <updated>2021-05-10T13:08:52.477Z</updated>
    
    <content type="html"><![CDATA[<h1 id="matlab安装mingw"><a class="markdownIt-Anchor" href="#matlab安装mingw"></a> Matlab安装minGW</h1><p>如果仅仅安装minGw而不需要Matlab使用<br />可参考<br /><a href="http://c.biancheng.net/view/8077.html#:~:text=MinGW%E7%9A%84%E5%AE%89%E8%A3%85.%20%E7%9B%B8%E6%AF%94%E5%9C%A8%20Linux%20%E5%B9%B3%E5%8F%B0%E4%B8%8A%E5%AE%89%E8%A3%85%20GCC%20%E7%BC%96%E8%AF%91%E7%8E%AF%E5%A2%83%EF%BC%8C%E5%9C%A8%20Windows%20%E5%B9%B3%E5%8F%B0%E4%B8%8A%E5%AE%89%E8%A3%85,MinGW%20%E7%9A%84%E5%AE%89%E8%A3%85%E4%BD%8D%E7%BD%AE.%204%29%20%E8%AF%BB%E8%80%85%E5%8F%AF%E6%A0%B9%E6%8D%AE%E8%87%AA%E5%B7%B1%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%9A%84%E5%AE%9E%E9%99%85%E6%83%85%E5%86%B5%EF%BC%8C%E8%87%AA%E5%AE%9A%E4%B9%89%20MinGW%20%E7%9A%84%E5%AE%89%E8%A3%85%E4%BD%8D%E7%BD%AE%EF%BC%88%E4%BE%8B%E5%A6%82%E6%88%91%E9%80%89%E6%8B%A9%E5%B0%86%E5%85%B6%E5%AE%89%E8%A3%85%E5%88%B0%20E%20%E7%9B%98%EF%BC%89%EF%BC%8C%E7%84%B6%E5%90%8E%E7%82%B9%E5%87%BB%E2%80%9Ccontinue%E2%80%9D%EF%BC%8C%E8%BF%9B%E5%85%A5%E4%B8%8B%E9%9D%A2%E7%9A%84%E5%AF%B9%E8%AF%9D%E6%A1%86%EF%BC%9A.">MinGW下载和安装教程</a></p><p>matlab使用minGW可能有版本限制</p><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mex -setup</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">错误使用 mex</span><br><span class="line">未找到支持的编译器或 SDK。您可以安装免费提供的 MinGW-w64 C&#x2F;C++ 编译器；请参阅安装 MinGW-w64 编译器。有关更多选项，请访问</span><br><span class="line">http:&#x2F;&#x2F;www.mathworks.com&#x2F;support&#x2F;compilers&#x2F;R2016b&#x2F;win64.html。</span><br></pre></td></tr></table></figure><p>考虑在附加功能中安装，在附加功能中搜 <code>mingw</code><br /><img src="https://lcg-pic-tencent-1258286866.cos.ap-chengdu.myqcloud.com/blog/QQ%E6%88%AA%E5%9B%BE20210510184634.jpg" alt="" /></p><p>安装这个，下载得到 <code>mingw.mlpkginstall</code>文件，用matlab打开它，如果你有多个版本的matlab，可能用错版本，考虑直接将此文件拖到matlab窗口里，或者</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">uiopen(&#39;C:\Users\LCG\Documents\mingw.mlpkginstall&#39;,1)</span><br></pre></td></tr></table></figure><p><img src="https://lcg-pic-tencent-1258286866.cos.ap-chengdu.myqcloud.com/blog/QQ%E6%88%AA%E5%9B%BE20210510172217.jpg" alt="" /></p><p>在高版本Maltab中应该能安装成功。<br />如果低版本出现<br /><img src="https://lcg-pic-tencent-1258286866.cos.ap-chengdu.myqcloud.com/blog/QQ%E6%88%AA%E5%9B%BE20210510172334.jpg" alt="" /><br />可按照下面方法解决<br /><img src="https://lcg-pic-tencent-1258286866.cos.ap-chengdu.myqcloud.com/blog/QQ%E6%88%AA%E5%9B%BE20210510180101.jpg" alt="" /><br /><a href="https://freefr.dl.sourceforge.net/project/tdm-gcc/TDM-GCC%20Installer/Previous/1.1309.0/tdm64-gcc-4.9.2.exe">https://freefr.dl.sourceforge.net/project/tdm-gcc/TDM-GCC%20Installer/Previous/1.1309.0/tdm64-gcc-4.9.2.exe </a></p><p>设置环境变量</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">setenv(&#39;MW_MINGW64_LOC&#39;,&#39;C:\TDM-GCC-64&#39;) </span><br></pre></td></tr></table></figure><p>如果还出错，可以参考<a href="https://blog.csdn.net/alxe_made/article/details/103765503">matlab报错：尝试将 SCRIPT xxx 作为函数执行</a>中的解决办法，即<strong>每次</strong>在设置中<code>更新工具箱路径缓存</code><br /><img src="https://lcg-pic-tencent-1258286866.cos.ap-chengdu.myqcloud.com/blog/QQ%E6%88%AA%E5%9B%BE20210510174703.jpg" alt="" /></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;matlab安装mingw&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#matlab安装mingw&quot;&gt;&lt;/a&gt; Matlab安装minGW&lt;/h1&gt;
&lt;p&gt;如果仅仅安装minGw而不需要Matlab使用&lt;br /&gt;
可参考&lt;br /&gt;</summary>
      
    
    
    
    <category term="Matlab" scheme="https://www.liuchanggeng.xyz/categories/Matlab/"/>
    
    
    <category term="软件安装入门" scheme="https://www.liuchanggeng.xyz/tags/%E8%BD%AF%E4%BB%B6%E5%AE%89%E8%A3%85%E5%85%A5%E9%97%A8/"/>
    
  </entry>
  
  <entry>
    <title>同软件多个版本相互冲突</title>
    <link href="https://www.liuchanggeng.xyz/2021/05/10/softwareGetStart/%E5%90%8C%E8%BD%AF%E4%BB%B6%E5%A4%9A%E4%B8%AA%E7%89%88%E6%9C%AC%E7%9B%B8%E4%BA%92%E5%86%B2%E7%AA%81/"/>
    <id>https://www.liuchanggeng.xyz/2021/05/10/softwareGetStart/%E5%90%8C%E8%BD%AF%E4%BB%B6%E5%A4%9A%E4%B8%AA%E7%89%88%E6%9C%AC%E7%9B%B8%E4%BA%92%E5%86%B2%E7%AA%81/</id>
    <published>2021-05-10T06:59:24.000Z</published>
    <updated>2021-05-10T13:25:41.375Z</updated>
    
    <content type="html"><![CDATA[<h1 id="同软件多个版本相互冲突"><a class="markdownIt-Anchor" href="#同软件多个版本相互冲突"></a> 同软件多个版本相互冲突</h1><p>安装多个版本的Matlab后，在bin文件夹下双击matlab.exe即可打开Matlab，但不同版本的此文件名称相同，如果创建快捷方式后有可能冲突出错。<br />要保证快捷方式名称不同，并且在各文件夹中名称一致。</p><p><strong>下图是开始屏幕相关的文件夹</strong><br /><img src="https://lcg-pic-tencent-1258286866.cos.ap-chengdu.myqcloud.com/blog/QQ%E6%88%AA%E5%9B%BE20210510150357.jpg" alt="" /></p><p><strong>安装目录</strong><br /><img src="https://lcg-pic-tencent-1258286866.cos.ap-chengdu.myqcloud.com/blog/QQ%E6%88%AA%E5%9B%BE20210510150416.jpg" alt="" /></p><p><img src="https://lcg-pic-tencent-1258286866.cos.ap-chengdu.myqcloud.com/blog/QQ%E6%88%AA%E5%9B%BE20210510150837.jpg" alt="" /></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;同软件多个版本相互冲突&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#同软件多个版本相互冲突&quot;&gt;&lt;/a&gt; 同软件多个版本相互冲突&lt;/h1&gt;
&lt;p&gt;安装多个版本的Matlab后，在bin文件夹下双击matlab.exe即可打开Matlab</summary>
      
    
    
    
    <category term="Matlab" scheme="https://www.liuchanggeng.xyz/categories/Matlab/"/>
    
    
    <category term="软件安装入门" scheme="https://www.liuchanggeng.xyz/tags/%E8%BD%AF%E4%BB%B6%E5%AE%89%E8%A3%85%E5%85%A5%E9%97%A8/"/>
    
  </entry>
  
  <entry>
    <title>STK 与Matlab 的连接</title>
    <link href="https://www.liuchanggeng.xyz/2021/05/10/softwareGetStart/STK%20%E4%B8%8EMatlab%20%E7%9A%84%E8%BF%9E%E6%8E%A5/"/>
    <id>https://www.liuchanggeng.xyz/2021/05/10/softwareGetStart/STK%20%E4%B8%8EMatlab%20%E7%9A%84%E8%BF%9E%E6%8E%A5/</id>
    <published>2021-05-10T03:45:32.000Z</published>
    <updated>2021-05-10T13:23:30.144Z</updated>
    
    <content type="html"><![CDATA[<h1 id="stk-与matlab-的连接"><a class="markdownIt-Anchor" href="#stk-与matlab-的连接"></a> STK 与Matlab 的连接</h1><p>参考链接：<br /><a href="https://help.agi.com/stk/index.htm#install/MATLABsetup.htm">https://help.agi.com/stk/index.htm#install/MATLABsetup.htm</a></p><p>确保STK和Matlab版本兼容<br /><img src="https://lcg-pic-tencent-1258286866.cos.ap-chengdu.myqcloud.com/blog/QQ%E6%88%AA%E5%9B%BE20210510121624.jpg" alt="" /><br />兼容信息也可在连接器文件夹的<code>version.txt</code>中查看<br /><img src="https://lcg-pic-tencent-1258286866.cos.ap-chengdu.myqcloud.com/blog/QQ%E6%88%AA%E5%9B%BE20210510123317.jpg" alt="" /></p><ul><li>在STK安装文件目录下查找MATLAB_Connectors或MATLAB_Connectors_X64 文件夹</li><li>双击 setup.exe</li></ul><p><img src="https://lcg-pic-tencent-1258286866.cos.ap-chengdu.myqcloud.com/blog/QQ%E6%88%AA%E5%9B%BE20210510122541.jpg" alt="" /></p><p><img src="https://lcg-pic-tencent-1258286866.cos.ap-chengdu.myqcloud.com/blog/QQ%E6%88%AA%E5%9B%BE20210510160216.jpg" alt="" /></p><p>Matlab中使用stkInit初始化</p><p>添加路径</p><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">addpath(<span class="string">&#x27;D:\AGI\STK 11\bin\Matlab&#x27;</span>)</span><br></pre></td></tr></table></figure><p>但有可能出现以下错误</p><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">尝试将 SCRIPT mexConnect 作为函数执行:</span><br><span class="line">D:\AGI\STK <span class="number">11</span>\bin\Matlab\mexConnect.m</span><br><span class="line"></span><br><span class="line">出错 stkValidScen (line <span class="number">20</span>)</span><br><span class="line">out = mexConnect(<span class="string">&#x27;stkValidScen&#x27;</span>);</span><br><span class="line"></span><br><span class="line">出错 stkInit (line <span class="number">15</span>)</span><br><span class="line"><span class="keyword">if</span> stkValidScen</span><br></pre></td></tr></table></figure><p>解决办法参考链接</p><p><a href="https://blog.csdn.net/weixin_43116425/article/details/104412291">STK 与 matlab 连接报错</a> ：<br />在运行stkInit前先运行C:\ProgramData\AGI\STK MATLAB文件夹下的<code>startup.m</code>文件</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;stk-与matlab-的连接&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#stk-与matlab-的连接&quot;&gt;&lt;/a&gt; STK 与Matlab 的连接&lt;/h1&gt;
&lt;p&gt;参考链接：&lt;br /&gt;
&lt;a href=&quot;https://help</summary>
      
    
    
    
    <category term="Matlab" scheme="https://www.liuchanggeng.xyz/categories/Matlab/"/>
    
    <category term="STK" scheme="https://www.liuchanggeng.xyz/categories/STK/"/>
    
    
    <category term="软件安装入门" scheme="https://www.liuchanggeng.xyz/tags/%E8%BD%AF%E4%BB%B6%E5%AE%89%E8%A3%85%E5%85%A5%E9%97%A8/"/>
    
  </entry>
  
  <entry>
    <title>Hexo批处理文件</title>
    <link href="https://www.liuchanggeng.xyz/2020/11/16/hexo/hexo-batch-process-file/"/>
    <id>https://www.liuchanggeng.xyz/2020/11/16/hexo/hexo-batch-process-file/</id>
    <published>2020-11-16T07:43:55.000Z</published>
    <updated>2021-05-10T13:22:35.760Z</updated>
    
    <content type="html"><![CDATA[<p>第一次建站，想把以前写过的markdown笔记上传到博客上，但是这些笔记散落在Github的若干repository上，我不想仅仅复制到\source_posts下，我希望原来的博客路径不变，每次更改github的笔记博客也会变。找了很多办法，都不方便，如将markdown文件渲染成html在用iframe嵌入博客中。<br />对于VScode中的Markdown Preview Enhanced插件的import功能是我最想要的。可以直接在markdown里插入任意位置markdown，十分方便，但Hexo我没找到插件支持。<br />本人目前网页技术小白，只好另辟蹊径。</p><p>最后写了一个matlab复制脚本，可以时间将其他路径中的markdown笔记复制到目标路径下。这样我可以批量复制所有笔记，每次更新也不用复制粘贴，直接运行脚本就可以了。</p><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">%% 用于导入其他文件夹中的md文件</span></span><br><span class="line"><span class="comment">%% 设置需要更新的路径(repo的路径)</span></span><br><span class="line">srcpath=[</span><br><span class="line"><span class="string">&quot;F:\github\Cpp-Notes&quot;</span>;    </span><br><span class="line">];</span><br><span class="line"><span class="comment">% 排除不想复制的文件夹</span></span><br><span class="line">exincludedir=[</span><br><span class="line"><span class="string">&quot;.&quot;</span>;</span><br><span class="line"><span class="string">&quot;..&quot;</span>;</span><br><span class="line">];</span><br><span class="line">dstpath=<span class="string">&quot;F:\github\blog\source\_posts\test&quot;</span>;<span class="comment">%目标文件夹</span></span><br><span class="line"><span class="comment">%% 遍历所有路径</span></span><br><span class="line">checkdir(dir(srcpath),<span class="number">1</span>,exincludedir,dstpath);</span><br></pre></td></tr></table></figure><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">%% 检查路径下所有文件</span></span><br><span class="line"><span class="comment">% pathlist :文件夹列表</span></span><br><span class="line"><span class="comment">% n:第n个文件</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">checkdir</span><span class="params">(pathlist,n,exincludedir,dstpath)</span></span></span><br><span class="line">    <span class="keyword">for</span> ii=n:<span class="built_in">length</span>(pathlist)</span><br><span class="line">       ptmp=pathlist(ii);</span><br><span class="line">       <span class="comment">%% 排除</span></span><br><span class="line">       <span class="keyword">if</span>(sum(ptmp.name==exincludedir))</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">       <span class="keyword">end</span></span><br><span class="line">       nextptmp=[ptmp.folder,<span class="string">&#x27;\&#x27;,ptmp.name];%子路径</span></span><br><span class="line"><span class="string">       if(isfolder(nextptmp))%是文件夹</span></span><br><span class="line"><span class="string">            nextptmp=[ptmp.folder,&#x27;</span>\<span class="string">&#x27;,ptmp.name];%子路径</span></span><br><span class="line"><span class="string">            checkdir(dir(nextptmp),1,exincludedir,dstpath);    </span></span><br><span class="line"><span class="string">       end</span></span><br><span class="line"><span class="string">       %后缀</span></span><br><span class="line"><span class="string">       [~,~,abc]=fileparts(ptmp.name);</span></span><br><span class="line"><span class="string">       % copy</span></span><br><span class="line"><span class="string">       if(abc==&quot;.md&quot;)</span></span><br><span class="line"><span class="string">            srcp=[ptmp.folder,&#x27;</span>\<span class="string">&#x27;,ptmp.name];</span></span><br><span class="line"><span class="string">            if isfolder(dstpath)~=1</span></span><br><span class="line"><span class="string">                mkdir(dstpath)</span></span><br><span class="line"><span class="string">            end</span></span><br><span class="line"><span class="string">            copyfile(srcp,dstpath);</span></span><br><span class="line"><span class="string">       end</span></span><br><span class="line"><span class="string">    end</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">end</span></span><br></pre></td></tr></table></figure><p>笔记Front-matter模板</p><ul><li><a href="https://hexo.io/zh-cn/docs/front-matter"></a></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">---</span><br><span class="line">title: Hexo批处理文件</span><br><span class="line">mathjax: true</span><br><span class="line">date: 2020-11-16 15:43:55</span><br><span class="line">tags:</span><br><span class="line">    - 建站</span><br><span class="line">    - 奇技淫巧</span><br><span class="line">categories:</span><br><span class="line">    - Hexo</span><br><span class="line">    - Matlab</span><br><span class="line">---</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;第一次建站，想把以前写过的markdown笔记上传到博客上，但是这些笔记散落在Github的若干repository上，我不想仅仅复制到\source_posts下，我希望原来的博客路径不变，每次更改github的笔记博客也会变。找了很多办法，都不方便，如将markdown</summary>
      
    
    
    
    <category term="Hexo" scheme="https://www.liuchanggeng.xyz/categories/Hexo/"/>
    
    <category term="Matlab" scheme="https://www.liuchanggeng.xyz/categories/Matlab/"/>
    
    
    <category term="建站" scheme="https://www.liuchanggeng.xyz/tags/%E5%BB%BA%E7%AB%99/"/>
    
    <category term="奇技淫巧" scheme="https://www.liuchanggeng.xyz/tags/%E5%A5%87%E6%8A%80%E6%B7%AB%E5%B7%A7/"/>
    
  </entry>
  
  <entry>
    <title>第一个Hexo博客</title>
    <link href="https://www.liuchanggeng.xyz/2020/11/14/hexo/my-first-hexo-blog/"/>
    <id>https://www.liuchanggeng.xyz/2020/11/14/hexo/my-first-hexo-blog/</id>
    <published>2020-11-14T07:50:34.000Z</published>
    <updated>2021-05-10T13:24:59.528Z</updated>
    
    <content type="html"><![CDATA[<h4 id="参考链接"><a class="markdownIt-Anchor" href="#参考链接"></a> 参考链接</h4><ul><li><a href="https://www.cnblogs.com/huanhao/p/hexobase.html">https://www.cnblogs.com/huanhao/p/hexobase.html</a></li><li><a href="https://zhuanlan.zhihu.com/p/26625249">https://zhuanlan.zhihu.com/p/26625249</a></li><li><a href="https://www.jianshu.com/p/bff1b1845ac9">Hexo 一篇文章多个 categories</a></li></ul><h4 id="更新博客"><a class="markdownIt-Anchor" href="#更新博客"></a> 更新博客</h4><ul><li>新建博客：</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hexo new &quot;新博客标题&quot;</span><br></pre></td></tr></table></figure><p>或直接新建一个markdown文件。</p><ul><li>本地预览：</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hexo s</span><br></pre></td></tr></table></figure><ul><li>上传</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">hexo clean</span><br><span class="line">hexo generate</span><br><span class="line">hexo deploy</span><br></pre></td></tr></table></figure><h4 id="问题"><a class="markdownIt-Anchor" href="#问题"></a> 问题</h4><p>可能博客上传后出现404<br />在repo的setting中重新save个人域名</p><p>blog\source文件夹下CNAME文件中设置域名，可以自动save域名。</p><p>参考链接</p><p><a href="https://www.cnblogs.com/xmilt/p/9518297.html">https://www.cnblogs.com/xmilt/p/9518297.html</a></p><p><a href="https://docs.github.com/en/pages/configuring-a-custom-domain-for-your-github-pages-site/managing-a-custom-domain-for-your-github-pages-site">https://docs.github.com/en/pages/configuring-a-custom-domain-for-your-github-pages-site/managing-a-custom-domain-for-your-github-pages-site</a></p><p><a href="https://blog.csdn.net/weixin_43645287/article/details/109603945">https://blog.csdn.net/weixin_43645287/article/details/109603945</a></p><h4 id="主题"><a class="markdownIt-Anchor" href="#主题"></a> 主题</h4><p>相关参考：</p><ul><li><a href="https://blog.csdn.net/zgd826237710/article/details/99671027">Hexo 好看的主题推荐</a></li><li><a href="https://blog.cofess.com/2017/11/01/hexo-blog-theme-pure-usage-description.html">pure主题</a></li></ul><h3 id="测试"><a class="markdownIt-Anchor" href="#测试"></a> 测试</h3><ul><li>数学公式测试</li></ul><p class='katex-block'><span class="katex-display"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>a</mi><mo>+</mo><mi>b</mi><mo>=</mo><mi>c</mi><mi>π</mi></mrow><annotation encoding="application/x-tex">a+b=c\pi</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.66666em;vertical-align:-0.08333em;"></span><span class="mord mathdefault">a</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathdefault">b</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">c</span><span class="mord mathdefault" style="margin-right:0.03588em;">π</span></span></span></span></span></p><p><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>λ</mi></mrow><annotation encoding="application/x-tex">\lambda</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathdefault">λ</span></span></span></span></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h4 id=&quot;参考链接&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#参考链接&quot;&gt;&lt;/a&gt; 参考链接&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;https://www.cnblogs.com/huanhao/p/hexobase.html&quot;&gt;ht</summary>
      
    
    
    
    <category term="Hexo" scheme="https://www.liuchanggeng.xyz/categories/Hexo/"/>
    
    
    <category term="Hexo" scheme="https://www.liuchanggeng.xyz/tags/Hexo/"/>
    
  </entry>
  
  <entry>
    <title>Hello World</title>
    <link href="https://www.liuchanggeng.xyz/2020/11/13/hexo/hello-world/"/>
    <id>https://www.liuchanggeng.xyz/2020/11/13/hexo/hello-world/</id>
    <published>2020-11-13T13:31:20.028Z</published>
    <updated>2020-11-15T08:55:51.758Z</updated>
    
    <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="quick-start"><a class="markdownIt-Anchor" href="#quick-start"></a> Quick Start</h2><h3 id="create-a-new-post"><a class="markdownIt-Anchor" href="#create-a-new-post"></a> Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="run-server"><a class="markdownIt-Anchor" href="#run-server"></a> Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="generate-static-files"><a class="markdownIt-Anchor" href="#generate-static-files"></a> Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="deploy-to-remote-sites"><a class="markdownIt-Anchor" href="#deploy-to-remote-sites"></a> Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;Welcome to &lt;a href=&quot;https://hexo.io/&quot;&gt;Hexo&lt;/a&gt;! This is your very first post. Check &lt;a href=&quot;https://hexo.io/docs/&quot;&gt;documentation&lt;/a&gt; for</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>内存对齐</title>
    <link href="https://www.liuchanggeng.xyz/2020/09/12/CPP-Notes/%E5%86%85%E5%AD%98%E5%AF%B9%E9%BD%90/"/>
    <id>https://www.liuchanggeng.xyz/2020/09/12/CPP-Notes/%E5%86%85%E5%AD%98%E5%AF%B9%E9%BD%90/</id>
    <published>2020-09-12T02:41:00.000Z</published>
    <updated>2020-11-16T09:14:38.121Z</updated>
    
    <content type="html"><![CDATA[<h3 id="内存对齐"><a class="markdownIt-Anchor" href="#内存对齐"></a> 内存对齐</h3><p><a href="https://zhuanlan.zhihu.com/p/30007037">C/C<ins>内存对齐详解</a><br /><a href="https://www.jianshu.com/p/666852837034">C/C</ins> 结构体及其数组的内存对齐</a><br />现代计算机中内存空间都是按照 byte 划分的，从理论上讲似乎对任何类型的变量的访问可以从任何地址开始，但是实际的计算机系统对基本类型数据在内存中存放的位置有限制，它们会要求这些数据的首地址的值是某个数k（通常它为4或8）的倍数，这就是所谓的内存对齐。</p><p><strong>内存对齐规则</strong><br />每个特定平台上的编译器都有自己的默认“对齐系数”（也叫对齐模数）。gcc中默认#pragma pack(4)，可以通过预编译命令#pragma pack(n)，n = <strong>1,2,4,8,16</strong>来改变这一系数。不能用一些奇怪的数，比如3，vscode报错了，但vstudio没报错，怀疑是强转了。</p><p>有效对其值：是给定值#pragma pack(n)和结构体中最长数据类型长度中较小的那个。<strong>有效对齐值</strong>也叫对齐单位。</p><p>了解了上面的概念后，我们现在可以来看看内存对齐需要遵循的规则：</p><p>(1) 结构体第一个成员的偏移量（offset）为0，以后每个成员相对于结构体首地址的 offset 都是该成员大小与有效对齐值中较小那个的整数倍，如有需要编译器会在成员之间加上填充字节。</p><p>(3) <strong>结构体的总大小为 有效对齐值 的整数倍</strong>，如有需要编译器会在最末一个成员之后加上填充字节。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> pack(8)<span class="comment">//window默认8，linux默认4</span></span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">S</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">char</span> a;<span class="comment">//起始偏移0-&gt;0</span></span><br><span class="line">    <span class="keyword">int</span> b;<span class="comment">//偏移min(8,4)=4-&gt;0XXX0000</span></span><br><span class="line">    <span class="keyword">short</span> c;<span class="comment">//偏移min(8,2)=2(8是2的倍数，不需要补齐)-&gt;0xxx|0000|00</span></span><br><span class="line">    <span class="keyword">double</span> d;<span class="comment">//min(8,8)=8(10不是8的倍数-&gt;16-&gt;补六位)-&gt;0xxx|0000|00xxxxxx|00000000//24</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">C</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">char</span> a;</span><br><span class="line">    <span class="keyword">int</span> b;</span><br><span class="line">    <span class="keyword">short</span> c;</span><br><span class="line">&#125;;<span class="comment">//同上，结构体对齐10-&gt;12(和长度最长成员的对齐)</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    S s;</span><br><span class="line">    C c;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%x\n&quot;</span>, &amp;s.a);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%x\n&quot;</span>, &amp;s.b);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%x\n&quot;</span>, &amp;s.c);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%x\n&quot;</span>, &amp;s.d);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%x\n&quot;</span>, &amp;c.a);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%x\n&quot;</span>, &amp;c.b);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%x\n&quot;</span>, &amp;c.c);</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="keyword">sizeof</span>(s) &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="keyword">sizeof</span>(c) &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="keyword">sizeof</span>(s.a) &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="keyword">sizeof</span>(s.b) &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="keyword">sizeof</span>(s.c) &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="keyword">sizeof</span>(s.d) &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="keyword">sizeof</span>(<span class="keyword">double</span>) &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br></pre></td></tr></table></figure><p><strong>windows debug 86</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">10ff7d8</span><br><span class="line">10ff7dc</span><br><span class="line">10ff7e0</span><br><span class="line">10ff7e8</span><br><span class="line">10ff7c4</span><br><span class="line">10ff7c8</span><br><span class="line">10ff7cc</span><br><span class="line">24</span><br><span class="line">12</span><br><span class="line">1</span><br><span class="line">4</span><br><span class="line">2</span><br><span class="line">8</span><br><span class="line">8</span><br></pre></td></tr></table></figure><p><strong>#pragma pack(4)</strong> ,<br /><strong>windows debug 86</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">f5fadc</span><br><span class="line">f5fae0</span><br><span class="line">f5fae4</span><br><span class="line">f5fae8</span><br><span class="line">f5fac8</span><br><span class="line">f5facc</span><br><span class="line">f5fad0</span><br><span class="line">20</span><br><span class="line">12</span><br><span class="line">1</span><br><span class="line">4</span><br><span class="line">2</span><br><span class="line">8</span><br><span class="line">8</span><br></pre></td></tr></table></figure><p>#pragma pack(1)即各变量内存总和</p><p>结构体内的数组(如int a[10])可以认为连续有10个int的变量。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> pack(8)</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">test</span> &#123;</span></span><br><span class="line"><span class="keyword">int</span> a;<span class="comment">//0-&gt;4</span></span><br><span class="line"><span class="keyword">char</span> b;<span class="comment">//4-&gt;1</span></span><br><span class="line"><span class="keyword">short</span> c;<span class="comment">//6-&gt;2</span></span><br><span class="line"><span class="keyword">char</span> d[<span class="number">17</span>];<span class="comment">//8-&gt;16+1=25</span></span><br><span class="line">&#125;;<span class="comment">//25补上3个字节后是min(8,int)的倍数 28</span></span><br></pre></td></tr></table></figure><p>C与指针：根据边界对齐要求<strong>降序排列</strong>结构体成员可以最大限度减少存储中浪费的内存空间。</p><h4 id="union"><a class="markdownIt-Anchor" href="#union"></a> union</h4><p>参考：C与指针211页<br />union，中文名“联合体、共用体”，在某种程度上类似结构体struct的一种数据结构，共用体(union)和结构体(struct)同样可以包含很多种数据类型和变量。<br />一个联合体的所有成员都<strong>存储在内部的同一位置</strong>，通过访问不同类型的联合成员，内存中相同的位组合可以被解释为不同的东西，联合在实现<strong>变体记录</strong>(内存中某个特定的区域将在不同的时刻存储不同类型的值)时很有用，但程序员必须负责确认实际存储的是那个变体并选择正确的联合成员以便访问数据。联合变量也可以进行初始化，但<strong>初始值必须为联合第一个成员的类型匹配</strong>（如果不匹配的话编译器会强转，可能的话，如double-&gt;int）。</p><p>区别：<br />结构体(struct)中所有变量是“共存”的——优点是“有容乃大”，全面；缺点是struct内存空间的分配是粗放的，不管用不用，全分配。<br />而联合体(union)中是各变量是“互斥”的——缺点就是不够“包容”；但优点是内存使用更为精细灵活，也节省了内存空间(一般不用数组，用指针代替数组，这样就不会又太大的变量)。</p><p>union联合体所有数据成员共享一段内存，<strong>后写入的成员数据将覆盖之前的成员数据</strong>，成员数据都有相同的首地址。</p><ul><li>内存对齐规则：没找到，自己猜的，以最大的变量(数组算总长度)为内部内存占的空间，然后按结构体的内存对齐思想，找内部最大的类型(数组算单个长度)和#pragma pack(n)中最小的，以此倍数补齐。</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> pack(8)</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">union</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">char</span> a[<span class="number">2</span>];</span><br><span class="line"><span class="keyword">char</span> b[<span class="number">999</span>];</span><br><span class="line">&#125;un;<span class="comment">//sizeof(un))=999;</span></span><br></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> pack(8)</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">union</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">short</span> a[<span class="number">2</span>];</span><br><span class="line"><span class="keyword">char</span> b[<span class="number">999</span>];</span><br><span class="line">&#125;un;<span class="comment">//sizeof(un))=1000;以short的倍数补齐</span></span><br></pre></td></tr></table></figure><h4 id="位段位域bit-field"><a class="markdownIt-Anchor" href="#位段位域bit-field"></a> 位段/位域(bit field)</h4><p>参考：C与指针<br /><a href="http://c.biancheng.net/view/2037.html">http://c.biancheng.net/view/2037.html</a><br /><img src="https://lcg-pic-tencent-1258286866.cos.ap-chengdu.myqcloud.com/a%5Cb%5C20200826111859_b3dab8ab5d8dc96f4c8a7573093a1f67.png" alt="a\b\20200826111859_b3dab8ab5d8dc96f4c8a7573093a1f67.png" /><br /><img src="https://lcg-pic-tencent-1258286866.cos.ap-chengdu.myqcloud.com/a%5Cb%5C20200826112057_2e9f9087d6b19c3407781d70b39cecb6.png" alt="a\b\20200826112057_2e9f9087d6b19c3407781d70b39cecb6.png" /><br /><img src="https://lcg-pic-tencent-1258286866.cos.ap-chengdu.myqcloud.com/a%5Cb%5C20200826112135_73e2f090768275127d4c0fa0e6894b7d.png" alt="a\b\20200826112135_73e2f090768275127d4c0fa0e6894b7d.png" /><br /><img src="https://lcg-pic-tencent-1258286866.cos.ap-chengdu.myqcloud.com/a%5Cb%5C20200826112544_0ec9353c30e080b2b8df6876b1f29a61.png" alt="a\b\20200826112544_0ec9353c30e080b2b8df6876b1f29a61.png" /><br /><img src="https://lcg-pic-tencent-1258286866.cos.ap-chengdu.myqcloud.com/a%5Cb%5C20200826112556_8e1d9d1f6d348e3cde8f8bca15f0380e.png" alt="a\b\20200826112556_8e1d9d1f6d348e3cde8f8bca15f0380e.png" /><br />如果冒号后面不加位数，会自动按类型的原本长度如int，char等分配。<br />概要：</p><ul><li>移植性</li><li>signed unsigned</li><li>内存分配方向</li><li>操作系统位数，位段最大长度(不能超过类型长度int，char等)</li></ul><p>总结：位段允许长度为奇数的一些值包装在一起以节省存储空间，源代码如果需要访问一个值内部的一些位，使用位段比较简单(也可以通过移位和屏蔽实现，目标代码中两种实现方式无区别)，位段是结构的一种，但它的长度以位为大卫指定，位段声明在本质上是不可移植的(也能移植，但需要考虑太多因素)</p><p><strong>百度</strong><br /><img src="https://lcg-pic-tencent-1258286866.cos.ap-chengdu.myqcloud.com/a%5Cb%5C20200826143505_29a8e1da282b88bff0cb109165302824.png" alt="a\b\20200826143505_29a8e1da282b88bff0cb109165302824.png" /><br /><img src="https://lcg-pic-tencent-1258286866.cos.ap-chengdu.myqcloud.com/a%5Cb%5C20200826144017_a3480f68f4749e0ba1da30c4c70861c3.png" alt="a\b\20200826144017_a3480f68f4749e0ba1da30c4c70861c3.png" /></p><p><strong>例题</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> pack(8)</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">union</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">long</span> i;</span><br><span class="line"><span class="keyword">char</span> j[<span class="number">10</span>];</span><br><span class="line"><span class="keyword">int</span> k;</span><br><span class="line">&#125;Data;<span class="comment">//最长10，按最大类型long4字节倍数-&gt;10-&gt;12</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">data1</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">int</span> m;<span class="comment">//4</span></span><br><span class="line">Data n;<span class="comment">// min(12,8)=8,4-&gt;8,8+12=20</span></span><br><span class="line"><span class="keyword">double</span> i;<span class="comment">//min(8,8)=8=&gt;20-&gt;24,24+8=32;</span></span><br><span class="line">&#125;test;<span class="comment">//最长12，32-&gt;12*3=36</span></span><br></pre></td></tr></table></figure><p>C 库宏 offsetof(type, member-designator) 会生成一个类型为 size_t 的整型常量，它是一个结构成员相对于结构开头的字节偏移量。成员是由 member-designator 给定的，结构的名称是在 type 中给定的</p><p>以下运行结果和我预想的不一致，没搞明白，有时间再看。就是结构体各首地址应该多少？为什么和分配内存对齐的结果不一致，难道是因为地址这样做方便程序员不考虑内存对齐就可以用指针指向具体成员？内部系统自己再转换成对齐后的地址？？？</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cout</span> &lt;&lt; (<span class="keyword">int</span>)offsetof(struct data1, m) &lt;&lt; <span class="built_in">endl</span>;<span class="comment">//0</span></span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; (<span class="keyword">int</span>)offsetof(struct data1, n) &lt;&lt; <span class="built_in">endl</span>;<span class="comment">//4</span></span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; (<span class="keyword">int</span>)offsetof(struct data1, i) &lt;&lt; <span class="built_in">endl</span>;<span class="comment">//16</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, &amp;data1::m);<span class="comment">//0</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, &amp;data1::n);<span class="comment">//4</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, &amp;data1::i);<span class="comment">//16</span></span><br></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, &amp;test);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, &amp;test.m);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, &amp;test.n);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, &amp;test.i);</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">6340928</span><br><span class="line">6340928</span><br><span class="line">6340932</span><br><span class="line">6340944</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h3 id=&quot;内存对齐&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#内存对齐&quot;&gt;&lt;/a&gt; 内存对齐&lt;/h3&gt;
&lt;p&gt;&lt;a href=&quot;https://zhuanlan.zhihu.com/p/30007037&quot;&gt;C/C&lt;ins&gt;内存对齐详解&lt;/a&gt;</summary>
      
    
    
    
    <category term="C/C++" scheme="https://www.liuchanggeng.xyz/categories/C-C/"/>
    
    
    <category term="学习笔记" scheme="https://www.liuchanggeng.xyz/tags/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>深浅拷贝</title>
    <link href="https://www.liuchanggeng.xyz/2020/09/09/CPP-Notes/%E6%B7%B1%E6%B5%85%E6%8B%B7%E8%B4%9D/"/>
    <id>https://www.liuchanggeng.xyz/2020/09/09/CPP-Notes/%E6%B7%B1%E6%B5%85%E6%8B%B7%E8%B4%9D/</id>
    <published>2020-09-09T03:43:00.000Z</published>
    <updated>2020-11-16T09:15:23.275Z</updated>
    
    <content type="html"><![CDATA[<h3 id="深浅拷贝"><a class="markdownIt-Anchor" href="#深浅拷贝"></a> 深浅拷贝</h3><p>浅拷贝：使用类的默认拷贝构造函数，按字节复制，对于指针型变量只复制指针本身。不会复制指针所指向的目标，两个成员指向相同的内存空间，可能造成多次释放。<br />没有指针时，浅拷贝是可行的。</p><p>深拷贝，自定义拷贝构造函数。</p><p>简单的测试，<strong>浅拷贝</strong>：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A2</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">A2() :a(<span class="number">0</span>),pa(<span class="literal">nullptr</span>) &#123;&#125;;</span><br><span class="line">~A2() &#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;~A2()&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="keyword">delete</span>[] pa;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">SetValue</span><span class="params">(<span class="keyword">int</span> b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span> (pa != <span class="literal">nullptr</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">delete</span>[] pa;</span><br><span class="line">&#125;</span><br><span class="line">pa = <span class="keyword">new</span> <span class="keyword">int</span>;</span><br><span class="line">*pa = b;</span><br><span class="line">a = b;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">GetValue</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;a:   &quot;</span> &lt;&lt; a &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;&amp;a:  &quot;</span> &lt;&lt; &amp;a &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;*pa: &quot;</span> &lt;&lt; pa &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;pa:  &quot;</span> &lt;&lt; *pa &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line"><span class="keyword">int</span> a;</span><br><span class="line"><span class="keyword">int</span>* pa;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    A2 a21;</span><br><span class="line">&#123;</span><br><span class="line">A2 a2;</span><br><span class="line">a2.SetValue(<span class="number">10</span>);</span><br><span class="line">a2.GetValue();</span><br><span class="line">a21 = a2;</span><br><span class="line">a21.GetValue();</span><br><span class="line">&#125;<span class="comment">//a2被析构</span></span><br><span class="line">a21.GetValue();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>结果</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">a:   <span class="number">10</span></span><br><span class="line">&amp;a:  <span class="number">012F</span>F80C</span><br><span class="line">*pa: <span class="number">01600550</span></span><br><span class="line">pa:  <span class="number">10</span></span><br><span class="line"></span><br><span class="line">a:   <span class="number">10</span></span><br><span class="line">&amp;a:  <span class="number">012F</span>F81C<span class="comment">//对象的地址不同</span></span><br><span class="line">*pa: <span class="number">01600550</span><span class="comment">//指针的值相同</span></span><br><span class="line">pa:  <span class="number">10</span></span><br><span class="line"></span><br><span class="line">~A2()</span><br><span class="line">a:   <span class="number">10</span></span><br><span class="line">&amp;a:  <span class="number">012F</span>F81C<span class="comment">//</span></span><br><span class="line">*pa: <span class="number">01600550</span></span><br><span class="line">pa:  <span class="number">-572662307</span><span class="comment">//浅拷贝，内存已释放</span></span><br></pre></td></tr></table></figure><p><strong>深拷贝</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A1</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">A1() :a(<span class="number">0</span>), pa(<span class="literal">nullptr</span>) &#123;&#125;;</span><br><span class="line">~A1() &#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;~A2()&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="keyword">delete</span>[] pa;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">SetValue</span><span class="params">(<span class="keyword">int</span> b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span> (pa != <span class="literal">nullptr</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">delete</span>[] pa;</span><br><span class="line">&#125;</span><br><span class="line">pa = <span class="keyword">new</span> <span class="keyword">int</span>;</span><br><span class="line">*pa = b;</span><br><span class="line">a = b;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">GetValue</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;a:   &quot;</span> &lt;&lt; a &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;&amp;a:  &quot;</span> &lt;&lt; &amp;a &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;*pa: &quot;</span> &lt;&lt; pa &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;pa:  &quot;</span> &lt;&lt; *pa &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line">A1&amp; <span class="keyword">operator</span>=(<span class="keyword">const</span> A1&amp; a1)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (&amp;a1 != <span class="keyword">this</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">this</span>-&gt;a = a1.a;</span><br><span class="line"><span class="keyword">int</span>* tmp = <span class="keyword">new</span> <span class="keyword">int</span>;</span><br><span class="line"><span class="keyword">if</span> (pa != <span class="literal">nullptr</span>) <span class="keyword">delete</span>[] pa;</span><br><span class="line">*tmp = *a1.pa;</span><br><span class="line">pa = tmp;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line"><span class="keyword">int</span> a;</span><br><span class="line"><span class="keyword">int</span>* pa;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    A1 a11;</span><br><span class="line">&#123;</span><br><span class="line">A1 a1;</span><br><span class="line">a1.SetValue(<span class="number">10</span>);</span><br><span class="line">a1.GetValue();</span><br><span class="line">a11 = a1;</span><br><span class="line">a11.GetValue();</span><br><span class="line">&#125;</span><br><span class="line">a11.GetValue();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">a:   10</span><br><span class="line">&amp;a:  0133F7F0</span><br><span class="line">*pa: 017A0550</span><br><span class="line">pa:  10</span><br><span class="line"></span><br><span class="line">a:   10</span><br><span class="line">&amp;a:  0133F800&#x2F;&#x2F;对象的地址不同</span><br><span class="line">*pa: 017A8D98&#x2F;&#x2F;指针的值不同</span><br><span class="line">pa:  10</span><br><span class="line"></span><br><span class="line">~A2()</span><br><span class="line">a:   10</span><br><span class="line">&amp;a:  0133F800</span><br><span class="line">*pa: 017A8D98&#x2F;&#x2F;析构后不受影响</span><br><span class="line">pa:  10</span><br></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    Person()&#123;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">explicit</span> <span class="title">Person</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span>* str_, <span class="keyword">int</span> len)</span> : <span class="title">strLen</span><span class="params">(len)</span></span>&#123;</span><br><span class="line">        str = (<span class="keyword">char</span>*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="keyword">char</span>)*len);</span><br><span class="line">        <span class="built_in">strcpy</span>(str, str_);</span><br><span class="line">    &#125;</span><br><span class="line">    ~Person()&#123;</span><br><span class="line">        <span class="keyword">if</span> (str != <span class="literal">nullptr</span>)&#123;</span><br><span class="line">            <span class="built_in">free</span>(str);</span><br><span class="line">            str = <span class="literal">nullptr</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//深拷贝</span></span><br><span class="line">    Person&amp; <span class="keyword">operator</span>=(<span class="keyword">const</span> Person&amp; person)&#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span> == &amp;person) <span class="keyword">return</span> *<span class="keyword">this</span>;<span class="comment">//(错误(*this == person) )</span></span><br><span class="line">        <span class="built_in">free</span>(str);</span><br><span class="line">        strLen = person.strLen;</span><br><span class="line">        str = (<span class="keyword">char</span> *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="keyword">char</span>) * (strLen+<span class="number">1</span>));</span><br><span class="line">        <span class="built_in">memset</span>(str, <span class="string">&#x27;\0&#x27;</span>, strLen);</span><br><span class="line">        <span class="built_in">strcpy</span>(str, person.str);</span><br><span class="line">        <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">char</span>* str;</span><br><span class="line">    <span class="keyword">int</span> strLen;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h3 id=&quot;深浅拷贝&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#深浅拷贝&quot;&gt;&lt;/a&gt; 深浅拷贝&lt;/h3&gt;
&lt;p&gt;浅拷贝：使用类的默认拷贝构造函数，按字节复制，对于指针型变量只复制指针本身。不会复制指针所指向的目标，两个成员指向相同的内存空间，可</summary>
      
    
    
    
    <category term="C/C++" scheme="https://www.liuchanggeng.xyz/categories/C-C/"/>
    
    
    <category term="学习笔记" scheme="https://www.liuchanggeng.xyz/tags/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>设计模式</title>
    <link href="https://www.liuchanggeng.xyz/2020/09/02/CPP-Notes/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    <id>https://www.liuchanggeng.xyz/2020/09/02/CPP-Notes/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/</id>
    <published>2020-09-02T09:36:00.000Z</published>
    <updated>2020-11-16T09:05:03.761Z</updated>
    
    <content type="html"><![CDATA[<h2 id="设计模式"><a class="markdownIt-Anchor" href="#设计模式"></a> 设计模式</h2><p>“每一个模式描述了一个在我们周围不断重复发生的问题，以及该问题的解决方案的核心。这样，你就能一次又一次地使用该方案而不必做重复劳动”。<br />当客户改变需求，可以很快改变</p><ul><li>理解松耦合设计思想</li><li>掌握面向对象设计原则</li><li>掌握重构技法改善设计</li><li>掌握GOF 核心设计模式</li></ul><p>设计模式目标：可复用<br />具体方法：面向对象</p><p>复用性：真正的复用性不是代码复用，是<strong>编译单位</strong>的复用性，二进制的复用性，在原来的代码后面加几行不是复用之前的代码，已经破坏了代码的结构，也可能会引起bug。<br />程序员要想到以后代码会扩展的情况。</p><p>如何解决<code>复杂性</code>？<br /><strong>分解</strong><br />人们面对复杂性有一个常见的做法：即<code>分而治之</code>，将大问题分解为多个小问题，将复杂问题分解为多个简单问题。<br /><strong>抽象</strong><br />更高层次来讲，人们处理复杂性有一个通用的技术，即抽象。由于不能掌握全部的复杂对象，我们选择忽视它的非本质细节，而去处理泛化和理想化了的对象模型。<br /><img src="https://lcg-pic-tencent-1258286866.cos.ap-chengdu.myqcloud.com/a%5Cb%5C20200901160715_c1f49289cc1f44bc589495d932b180f5.png" alt="a\b\20200901160715_c1f49289cc1f44bc589495d932b180f5.png" /><br />多态可以使得接口保持一致，新增不同的设计方法。</p><h3 id="面向对象设计原则"><a class="markdownIt-Anchor" href="#面向对象设计原则"></a> 面向对象设计原则</h3><ul><li>依赖倒置原则（DIP）<ul><li>高层模块(稳定)不应该依赖于低层模块(变化)，二者都应该依赖于抽象(稳定) 。</li><li>抽象(稳定)不应该依赖于实现细节(变化) ，实现细节应该依赖于抽象(稳定)。</li></ul></li></ul><p><img src="https://lcg-pic-tencent-1258286866.cos.ap-chengdu.myqcloud.com/a%5Cb%5C20200901180039_ef80ab50f29042b3d512cee811ce6f08.png" alt="a\b\20200901180039_ef80ab50f29042b3d512cee811ce6f08.png" /><br />修改低层会影响高层<br /><img src="https://lcg-pic-tencent-1258286866.cos.ap-chengdu.myqcloud.com/a%5Cb%5C20200901180052_9d7b17724553c1a38eeee45cfc122393.png" alt="a\b\20200901180052_9d7b17724553c1a38eeee45cfc122393.png" /><br />抽象不变</p><ul><li><p>开放封闭原则（OCP）(开闭原则)</p><ul><li>对扩展开放，对更改封闭。</li><li>类模块应该是可扩展的，但是不可修改。</li></ul></li><li><p>单一职责原则(SRP)</p><ul><li>一个类已更改仅有一个引起它变化的原因</li><li>变化的方向隐含着类的责任</li></ul></li><li><p>Liskov替换原则(LSP),里氏代换原则,is a的另外一种表达方式</p><ul><li>子类必须能够替换他们的基类(IS-A)，(设计子类不应该不能使用父类功能)</li><li>继承表达类型抽象</li></ul></li><li><p>接口隔离原则（ISP）</p><ul><li>不应该强迫客户程序依赖他们不用的方法</li><li>接口应该小而完备</li></ul></li><li><p>优先使用对象组合，和不是类继承</p><ul><li>类继承通常为&quot;白箱复用&quot;，对象组合通常为“黑箱复用”。</li><li>继承在某种程度上破坏了封装性(父类给子类暴露的较多)，子类父类耦合度高</li><li>而对象组合则只要求被组合的对象具有良好定义的接口，耦合度低。 (有点像我在调制识别时写的helper类，这个类和识别类不是继承关系，写成对象组合，即一个类里面定义了另一个类)</li></ul></li><li><p>封装变化点</p><ul><li>使用封装来创建对象之间的分界层，让设计者可以在分界层进行修改，而不会对另一侧产生不良的影响，从而是实现层次间的松耦合。<br />封装的作用不仅仅是封装代码和数据，更高层次的理解是封装变化和稳定，一侧变化，一侧稳定。(参考依赖倒置原则的两个图，感觉项目中通过一个大的信号生成类去隔离各种调制信号生成方式类就是这种思想)</li></ul></li><li><p>针对接口编程，而不是针对实现编程(依赖倒置原则的另一个角度。往往违背其中一个原则，另一个原则也会违背)</p><ul><li>不讲变量声明为某个特定的具体类，而是声明为某个接口。</li><li>客户程序无需获知对象的具体类型，只需要知道对象所具有的接口。</li><li>减少系统中各部分的依赖关系，从而实现<code>“高内聚，低耦合”</code></li></ul></li></ul><p>违背接口原则</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">vector</span>&lt;Line&gt; lineVector;</span><br><span class="line"><span class="built_in">vector</span>&lt;Rect&gt; rectVector;</span><br></pre></td></tr></table></figure><p>面向接口的设计</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">vector</span>&lt;Shape*&gt; shapeVector;<span class="comment">//放抽象接口</span></span><br><span class="line">...</span><br><span class="line">shapeVector[i]-&gt;Draw(e.Graphics);<span class="comment">//多态调用，各负其值</span></span><br></pre></td></tr></table></figure><p>面向接口设计<br />产业强盛的标志，接口设计是一种专门的工作，可以分工协作，才能实现复用性。</p><p><img src="https://lcg-pic-tencent-1258286866.cos.ap-chengdu.myqcloud.com/a%5Cb%5C20200901205647_60d8cb5506d588b0be7b75e6de43f601.png" alt="a\b\20200901205647_60d8cb5506d588b0be7b75e6de43f601.png" /><br /><img src="https://lcg-pic-tencent-1258286866.cos.ap-chengdu.myqcloud.com/a%5Cb%5C20200901205833_7bc53ea71786261cb2e8a0086a1c2428.png" alt="a\b\20200901205833_7bc53ea71786261cb2e8a0086a1c2428.png" /><br /><img src="https://lcg-pic-tencent-1258286866.cos.ap-chengdu.myqcloud.com/a%5Cb%5C20200901205847_867f27e696f17b2df75e2da6f5e930ee.png" alt="a\b\20200901205847_867f27e696f17b2df75e2da6f5e930ee.png" /><br /><img src="https://lcg-pic-tencent-1258286866.cos.ap-chengdu.myqcloud.com/a%5Cb%5C20200901205912_58da37e346192dfd51157caaf2c5f022.png" alt="a\b\20200901205912_58da37e346192dfd51157caaf2c5f022.png" /><br />重构关键技法</p><ul><li>静态-&gt;动态</li><li>早绑定-&gt;晚绑定</li><li>继承-&gt;组合</li><li>编译时依赖-&gt;运行时依赖</li><li>紧耦合-&gt;松耦合</li></ul><p>设计模式就是在稳定和和变化中找到隔离点。<br /><a href="https://blog.csdn.net/huashuolin001/article/details/108258802">https://blog.csdn.net/huashuolin001/article/details/108258802</a><br /><a href="https://www.jianshu.com/p/69eef7651667">https://www.jianshu.com/p/69eef7651667</a><br /><a href="https://www.runoob.com/design-pattern/design-pattern-intro.html">https://www.runoob.com/design-pattern/design-pattern-intro.html</a><br /><img src="https://lcg-pic-tencent-1258286866.cos.ap-chengdu.myqcloud.com/a%5Cb%5C20200829200028_9238760f181d58e9226208574a9237b0.png" alt="a\b\20200829200028_9238760f181d58e9226208574a9237b0.png" /><br /><img src="https://lcg-pic-tencent-1258286866.cos.ap-chengdu.myqcloud.com/a%5Cb%5C20200829200131_959d2e618e295a7ec41c619af074a683.png" alt="a\b\20200829200131_959d2e618e295a7ec41c619af074a683.png" /></p><h3 id="单例模式-创建型模式"><a class="markdownIt-Anchor" href="#单例模式-创建型模式"></a> 单例模式-创建型模式</h3><p><a href="https://blog.csdn.net/sinat_21107433/article/details/102649056">https://blog.csdn.net/sinat_21107433/article/details/102649056</a></p><p>如window任务管理器，回收站，多线程线程池，文件系统，一个数字滤波器只有一个AD转换器，一个会计系统专用于一个公司</p><ul><li>一个类只有一个实例，该类能自行创建实例</li><li>类的构造函数(注意析构函数不影响)设为私有的，外部类就无法调用该构造函数，也就无法生成多个实例。</li></ul><p>写法：</p><ul><li>懒汉式：<ul><li>线程不安全</li><li>加锁(代价过高)</li><li>双检测锁(reorder:编译器指令重排)</li><li>C++11双检测锁（m_mutex）</li><li>C<ins>11局部静态变量(Effictive C</ins>的作者提出的)</li></ul></li><li>饿汉式<ul><li>线程安全</li></ul></li></ul><p><strong>线程不安全的写法</strong><br /><strong>懒汉式:</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Singleton</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line"><span class="keyword">static</span> Singleton* m_instance;<span class="comment">//这里是类指针</span></span><br><span class="line">Singleton() &#123;&#125;;<span class="comment">//不能delete，否则getInstance调用不了</span></span><br><span class="line">Singleton(<span class="keyword">const</span> Singleton&amp; other) = <span class="keyword">delete</span>;<span class="comment">//不希望有拷贝构造</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="keyword">static</span> Singleton* <span class="title">getInstance</span><span class="params">()</span></span>;<span class="comment">//获得实例</span></span><br><span class="line">&#125;;</span><br><span class="line">Singleton* Singleton::m_instance = <span class="literal">nullptr</span>;<span class="comment">//开头不用写static</span></span><br><span class="line"><span class="function">Singleton* <span class="title">Singleton::getInstance</span><span class="params">()</span><span class="comment">//这里开头也不用写static</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span> (m_instance == <span class="literal">nullptr</span>)<span class="comment">//懒汉：使用时创建</span></span><br><span class="line">&#123;</span><br><span class="line">m_instance = <span class="keyword">new</span> Singleton();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> m_instance;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>线程安全的写法(代价过高)</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Singleton* <span class="title">Singleton::getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Lock lock;<span class="comment">//</span></span><br><span class="line">    <span class="keyword">if</span> (m_instance == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">        m_instance = <span class="keyword">new</span> Singleton();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> m_instance;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><p><strong>双检查锁（错误的写法）</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">////双检查锁，但由于内存读写reorder不安全，出问题概率很高，不能这么用</span></span><br><span class="line"><span class="comment">//假想顺序</span></span><br><span class="line"><span class="comment">//step1 :分配内存</span></span><br><span class="line"><span class="comment">//step2：构造</span></span><br><span class="line"><span class="comment">//step3：返回指针</span></span><br><span class="line"><span class="comment">//编译器reorder：CPU指令级(有可能，编译优化)：</span></span><br><span class="line"><span class="comment">//step1 : 分配内存</span></span><br><span class="line"><span class="comment">//step2：返回指针</span></span><br><span class="line"><span class="comment">//step3：构造</span></span><br><span class="line"><span class="function">Singleton* <span class="title">Singleton::getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span>(m_instance==<span class="literal">nullptr</span>)&#123;<span class="comment">//第一个判空为了判断是第一次创建</span></span><br><span class="line">        Lock lock;<span class="comment">//两个线程只有一个能先锁，不能都锁上</span></span><br><span class="line">        <span class="keyword">if</span> (m_instance == <span class="literal">nullptr</span>) &#123;<span class="comment">//第二个判空是为了当两个线程同时判空后，一个先锁，让一个先new出来后另一个直接跳过，否则还是会多次创建。</span></span><br><span class="line">            m_instance = <span class="keyword">new</span> Singleton();<span class="comment">//可能在某个线程new的时候未分配内存就返回指针，导致其他线程判不为空，返回了一个错误的指针</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> m_instance;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><strong>C++11双检测锁,内存栅栏</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//C++ 11版本之后的跨平台实现 (volatile)</span></span><br><span class="line"><span class="built_in">std</span>::atomic&lt;Singleton*&gt; Singleton::m_instance;</span><br><span class="line"><span class="built_in">std</span>::mutex Singleton::m_mutex;</span><br><span class="line"></span><br><span class="line"><span class="function">Singleton* <span class="title">Singleton::getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Singleton* tmp = m_instance.load(<span class="built_in">std</span>::memory_order_relaxed);</span><br><span class="line">    <span class="built_in">std</span>::atomic_thread_fence(<span class="built_in">std</span>::memory_order_acquire);<span class="comment">//获取内存fence</span></span><br><span class="line">    <span class="keyword">if</span> (tmp == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">        <span class="function"><span class="built_in">std</span>::lock_guard&lt;<span class="built_in">std</span>::mutex&gt; <span class="title">lock</span><span class="params">(m_mutex)</span></span>;</span><br><span class="line">        tmp = m_instance.load(<span class="built_in">std</span>::memory_order_relaxed);</span><br><span class="line">        <span class="keyword">if</span> (tmp == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">            tmp = <span class="keyword">new</span> Singleton;</span><br><span class="line">            <span class="built_in">std</span>::atomic_thread_fence(<span class="built_in">std</span>::memory_order_release);<span class="comment">//释放内存fence</span></span><br><span class="line">            m_instance.store(tmp, <span class="built_in">std</span>::memory_order_relaxed);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> tmp;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><strong>局部静态变量(最好的写法)</strong><br /><a href="https://blog.csdn.net/wang_anna/article/details/103761565">https://blog.csdn.net/wang_anna/article/details/103761565</a></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//类内</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> Singleton* <span class="title">getInstance</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">static</span> Singleton m_instance;<span class="comment">//是个对象</span></span><br><span class="line">    <span class="keyword">return</span> &amp;m_instance;<span class="comment">//返回地址</span></span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure><p><strong>饿汉式，线程安全</strong><br />该模式的特点是类一旦加载就创建一个单例，保证在调用 getInstance 方法之前单例已经存在了。<br />不管是不是用都会初始化，浪费内存</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//1.在类中new</span></span><br><span class="line"><span class="comment">//2.在类外new</span></span><br><span class="line">Singleton* Singleton::m_instance = <span class="keyword">new</span> Singleton();</span><br></pre></td></tr></table></figure><p><img src="https://lcg-pic-tencent-1258286866.cos.ap-chengdu.myqcloud.com/a%5Cb%5C20200830155206_6ada8bd143aaa876cad328c318cb62b2.png" alt="a\b\20200830155206_6ada8bd143aaa876cad328c318cb62b2.png" /></p><h3 id="模板模式template-pattern-类行为型模式"><a class="markdownIt-Anchor" href="#模板模式template-pattern-类行为型模式"></a> 模板模式(template Pattern)-类行为型模式</h3><p><a href="https://blog.csdn.net/sinat_21107433/article/details/102994585">https://blog.csdn.net/sinat_21107433/article/details/102994585</a></p><p>就是在基类中把算法的框架搭好，在子类中去实现。框架是不变的部分，将可变的行为留给子类。变的部分写成虚函数，子类重写实现虚函数。<br /><strong>非模板模式</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//程序库开发人员</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Library</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Step1</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="comment">//...</span></span><br><span class="line">&#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Step3</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="comment">//...</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Step5</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="comment">//...</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//应用程序开发人员</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Application</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">Step2</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="comment">//...</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Step4</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="comment">//...</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="function">Library <span class="title">lib</span><span class="params">()</span></span>;</span><br><span class="line"><span class="function">Application <span class="title">app</span><span class="params">()</span></span>;</span><br><span class="line">lib.Step1();</span><br><span class="line"><span class="keyword">if</span> (app.Step2())&#123;</span><br><span class="line">lib.Step3();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">4</span>; i++)&#123;</span><br><span class="line">app.Step4();</span><br><span class="line">&#125;</span><br><span class="line">lib.Step5();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>模板模式</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//程序库开发人员</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Library</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">//稳定 template method</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Run</span><span class="params">()</span></span>&#123;</span><br><span class="line">        Step1();</span><br><span class="line">        <span class="keyword">if</span> (Step2()) &#123; <span class="comment">//支持变化 ==&gt; 虚函数的多态调用</span></span><br><span class="line">            Step3(); </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">4</span>; i++)&#123;</span><br><span class="line">            Step4(); <span class="comment">//支持变化 ==&gt; 虚函数的多态调用</span></span><br><span class="line">        &#125;</span><br><span class="line">        Step5();</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">virtual</span> ~Library()&#123; &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Step1</span><span class="params">()</span> </span>&#123; <span class="comment">//稳定</span></span><br><span class="line">        <span class="comment">//.....</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Step3</span><span class="params">()</span> </span>&#123;<span class="comment">//稳定</span></span><br><span class="line">        <span class="comment">//.....</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Step5</span><span class="params">()</span> </span>&#123; <span class="comment">//稳定</span></span><br><span class="line"><span class="comment">//.....</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">bool</span> <span class="title">Step2</span><span class="params">()</span> </span>= <span class="number">0</span>;<span class="comment">//变化</span></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">Step4</span><span class="params">()</span> </span>=<span class="number">0</span>; <span class="comment">//变化</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//应用程序开发人员</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Application</span> :</span> <span class="keyword">public</span> Library &#123;</span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="keyword">bool</span> <span class="title">Step2</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="comment">//... 子类重写实现</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">Step4</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="comment">//... 子类重写实现</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Library* pLib=<span class="keyword">new</span> Application();</span><br><span class="line">    pLib-&gt;Run();</span><br><span class="line">    <span class="keyword">delete</span> pLib;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>模板方法模式是基于类的继承的一种设计模式，使用非常频繁，被广泛应用于框架设计。</p><p><strong>优点：</strong></p><ul><li>在基类中定义算法的框架，并声明一些流程方法，由具体派生类实现细节，派生类中的实现并不会影响基类定义的算法的框架流程；</li><li>公共行为在基类中提供实现，有利于代码复用；</li><li>派生类可以覆盖基类的方法，重新实现某些方法，具有灵活性；<br />可以很方便的扩展和更换派生类而不影响基类和其他派生类，符合开闭原则和单一职责原则。</li></ul><p><strong>缺点：</strong></p><ul><li>模板方法模式要为每一个不同的基本方法提供一个派生类，如果基类中基本方法很多，那系统中会定义很多个派生类，导致类的个数很多，系统更加庞大。</li></ul><h3 id="工厂模式factory-method对象创建型模式"><a class="markdownIt-Anchor" href="#工厂模式factory-method对象创建型模式"></a> 工厂模式(Factory Method)对象创建型模式</h3><p>别名：虚构造器</p><ul><li>“对象创建”模式<br />通过“对象创建” 模式绕开new，来避免对象创建（new）过程中所导致的紧耦合（依赖具体类），从而支持对象创建的稳定。它是接口抽象之后的第一步工作。</li></ul><p>定义一个用于创建对象的接口，让子类决定实例化哪一个类，使一个类的实例化延迟(目的：解耦，手段：虚函数<code>virtual</code>)到子类.</p><p>一般适用于不确定new后面的类是什么类型，或者希望由子类指定所创建的对象的时候。</p><p>优点： 1、一个调用者想创建一个对象，只要知道其名称就可以了。 2、扩展性高，如果想增加一个产品，只要扩展一个工厂类就可以。 3、屏蔽产品的具体实现，调用者只关心产品的接口。</p><p>缺点：每次增加一个产品时，都需要增加一个具体类和对象实现工厂，使得系统中类的个数成倍增加，在一定程度上增加了系统的复杂度，同时也增加了系统具体类的依赖。这并不是什么好事</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//抽象类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ISplitter</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">split</span><span class="params">()</span></span>=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">virtual</span> ~ISplitter()&#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//工厂基类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SplitterFactory</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> ISplitter* <span class="title">CreateSplitter</span><span class="params">()</span></span>=<span class="number">0</span>;<span class="comment">//返回new出来的对象指针</span></span><br><span class="line">    <span class="comment">//virtual ISplitter1* CreateSplitter()=0;如果有多个ISplitter并且相互有联系，可以都在这里写成虚函数，这样写就是抽象工厂。</span></span><br><span class="line">    <span class="comment">//virtual ISplitter2* CreateSplitter()=0;</span></span><br><span class="line">    <span class="keyword">virtual</span> ~SplitterFactory()&#123;&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//具体类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">BinarySplitter</span> :</span> <span class="keyword">public</span> ISplitter&#123;</span><br><span class="line">    </span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TxtSplitter</span>:</span> <span class="keyword">public</span> ISplitter&#123;</span><br><span class="line">    </span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">PictureSplitter</span>:</span> <span class="keyword">public</span> ISplitter&#123;</span><br><span class="line">    </span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">VideoSplitter</span>:</span> <span class="keyword">public</span> ISplitter&#123;</span><br><span class="line">    </span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//具体工厂</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">BinarySplitterFactory</span>:</span> <span class="keyword">public</span> SplitterFactory&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> ISplitter* <span class="title">CreateSplitter</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> BinarySplitter();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TxtSplitterFactory</span>:</span> <span class="keyword">public</span> SplitterFactory&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> ISplitter* <span class="title">CreateSplitter</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> TxtSplitter();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">PictureSplitterFactory</span>:</span> <span class="keyword">public</span> SplitterFactory&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> ISplitter* <span class="title">CreateSplitter</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> PictureSplitter();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">VideoSplitterFactory</span>:</span> <span class="keyword">public</span> SplitterFactory&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> ISplitter* <span class="title">CreateSplitter</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> VideoSplitter();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MainForm</span> :</span> <span class="keyword">public</span> Form</span><br><span class="line">&#123;</span><br><span class="line">    SplitterFactory*  factory;<span class="comment">//工厂</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    </span><br><span class="line">    MainForm(SplitterFactory*  factory)&#123;<span class="comment">//SplitterFactory是基类，传进来子类</span></span><br><span class="line">        <span class="keyword">this</span>-&gt;factory=factory;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Button1_Click</span><span class="params">()</span></span>&#123;</span><br><span class="line">        ISplitter * splitter=</span><br><span class="line">            factory-&gt;CreateSplitter(); <span class="comment">//多态new  ，返回一个ISplitter的子类，new隐藏在CreateSplitter里</span></span><br><span class="line">        splitter-&gt;split();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="抽象工厂-对象创建型"><a class="markdownIt-Anchor" href="#抽象工厂-对象创建型"></a> 抽象工厂 -对象创建型</h3><p>和工厂模式十分相似，解决的问题也差不多。工厂模式是抽象工厂的特例。当工厂基类中的要扩展的虚函数只有一个时，就是工厂模式，多个时，就是抽像工厂，因为这多个虚函数之间有相互依赖性，如果定义多个基类，不好处理。<br />高内聚，松耦合。</p><ul><li>“对象创建”模式<br />通过“对象创建” 模式绕开new，来避免对象创建（new）过程中所导致的紧耦合（依赖具体类），从而支持对象创建的稳定。它是接口抽象之后的第一步工作。</li><li>动机（Motivation）<ul><li>在软件系统中，经常面临着<code>“一系列相互依赖的对象”</code>(和工厂模式的区别)的创建工作；同时，由于需求的变化，往往存在更多系列对象的创建工作。</li><li>如何应对这种变化？如何绕过常规的对象创建方法(new)，提供一种“封装机制”来避免客户程序和这种“多系列具体对象创建工作”的紧耦合？</li></ul></li></ul><p>GOF定义-提供一个接口，让该接口负责创建一系列“相关或者相互依赖的对象”，无需指定它们具体的类。<br /><img src="https://lcg-pic-tencent-1258286866.cos.ap-chengdu.myqcloud.com/a%5Cb%5C20200902152029_633d727d084e9c33abe00a9b1921b7ae.png" alt="a\b\20200902152029_633d727d084e9c33abe00a9b1921b7ae.png" /></p><h3 id="策略模式-组件协作模式"><a class="markdownIt-Anchor" href="#策略模式-组件协作模式"></a> 策略模式-组件协作模式</h3><ul><li><p>“组件协作”模式:<br />现代软件专业分工之后的第一个结果是“框架与应用程序的划分”，“组件协作”模式通过晚期绑定，来实现框架与应用程序之间的松耦合，是二者之间协作时常用的模式。</p></li><li><p>动机（Motivation）</p><ul><li>在软件构建过程中，某些对象使用的算法可能多种多样，经常改变，如果将这些算法都编码到对象中，将会使对象变得异常复杂；而且有时候支持不使用的算法也是一个性能负担(如果使用if else，那么所有的代码都会放到代码段里，大量代码可能造成负担，装载到CPU的高级缓存等等被迫挤到主存或内存里，而写成多态的，就没问题))。</li><li>如何在运行时根据需要透明地更改对象的算法？将算法与对象本身解耦，从而避免上述问题？</li></ul></li></ul><p>定义一系列算法，把它们一个个封装起来，并且使它们可互相替换（变化）。该模式使得算法可独立于使用它的客户程序(稳定)而变化（扩展，子类化）。<br />——《设计模式》GoF<br /><strong>违背开闭原则</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">TaxBase</span> &#123;</span></span><br><span class="line">CN_Tax,</span><br><span class="line">US_Tax,</span><br><span class="line">DE_Tax,</span><br><span class="line">FR_Tax       <span class="comment">//更改</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SalesOrder</span>&#123;</span></span><br><span class="line">    TaxBase tax;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">double</span> <span class="title">CalculateTax</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="comment">//...</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> (tax == CN_Tax)&#123;</span><br><span class="line">            <span class="comment">//CN***********</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (tax == US_Tax)&#123;</span><br><span class="line">            <span class="comment">//US***********</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (tax == DE_Tax)&#123;</span><br><span class="line">            <span class="comment">//DE***********</span></span><br><span class="line">        &#125;   </span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (tax == FR_Tax)&#123;  </span><br><span class="line">            <span class="comment">//更改   </span></span><br><span class="line">            <span class="comment">//...   </span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">//....</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><strong>策略模式</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TaxStrategy</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">double</span> <span class="title">Calculate</span><span class="params">(<span class="keyword">const</span> Context&amp; context)</span></span>=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">virtual</span> ~TaxStrategy()&#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CNTax</span> :</span> <span class="keyword">public</span> TaxStrategy&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">double</span> <span class="title">Calculate</span><span class="params">(<span class="keyword">const</span> Context&amp; context)</span></span>&#123;</span><br><span class="line">        <span class="comment">//***********</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">USTax</span> :</span> <span class="keyword">public</span> TaxStrategy&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">double</span> <span class="title">Calculate</span><span class="params">(<span class="keyword">const</span> Context&amp; context)</span></span>&#123;</span><br><span class="line">        <span class="comment">//***********</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">DETax</span> :</span> <span class="keyword">public</span> TaxStrategy&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">double</span> <span class="title">Calculate</span><span class="params">(<span class="keyword">const</span> Context&amp; context)</span></span>&#123;</span><br><span class="line">        <span class="comment">//***********</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//扩展</span></span><br><span class="line"><span class="comment">//*********************************</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">FRTax</span> :</span> <span class="keyword">public</span> TaxStrategy&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="keyword">double</span> <span class="title">Calculate</span><span class="params">(<span class="keyword">const</span> Context&amp; context)</span></span>&#123;</span><br><span class="line"><span class="comment">//.........</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SalesOrder</span>&#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    TaxStrategy* strategy;<span class="comment">//多态指针</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    SalesOrder(StrategyFactory* strategyFactory)&#123;</span><br><span class="line">        <span class="keyword">this</span>-&gt;strategy = strategyFactory-&gt;NewStrategy();</span><br><span class="line">    &#125;</span><br><span class="line">    ~SalesOrder()&#123;</span><br><span class="line">        <span class="keyword">delete</span> <span class="keyword">this</span>-&gt;strategy;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">double</span> <span class="title">CalculateTax</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="comment">//...</span></span><br><span class="line">        <span class="function">Context <span class="title">context</span><span class="params">()</span></span>;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">double</span> val = </span><br><span class="line">            strategy-&gt;Calculate(context); <span class="comment">//多态调用</span></span><br><span class="line">        <span class="comment">//...</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="观察者模式-组合"><a class="markdownIt-Anchor" href="#观察者模式-组合"></a> 观察者模式-组合</h3><ul><li><p>“组件协作”模式:<br />现代软件专业分工之后的第一个结果是“框架与应用程序的划分”，“组件协作”模式通过晚期绑定，来实现框架与应用程序之间的松耦合，是二者之间协作时常用的模式。</p></li><li><p>动机（Motivation）</p><ul><li>在软件构建过程中，我们需要为某些对象建立一种“通知依赖关系” ——<strong>一个对象（目标对象）的状态发生改变，所有的依赖对象（观察者对象）都将得到通知</strong>。如果这样的依赖关系过于紧密，将使软件不能很好地抵御变化。</li><li>使用面向对象技术，可以将这种依赖关系弱化，并形成一种稳定的依赖关系。从而实现软件体系结构的松耦合。</li></ul></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;设计模式&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#设计模式&quot;&gt;&lt;/a&gt; 设计模式&lt;/h2&gt;
&lt;p&gt;“每一个模式描述了一个在我们周围不断重复发生的问题，以及该问题的解决方案的核心。这样，你就能一次又一次地使用该方案而不必做重复劳动”</summary>
      
    
    
    
    <category term="C/C++" scheme="https://www.liuchanggeng.xyz/categories/C-C/"/>
    
    
    <category term="学习笔记" scheme="https://www.liuchanggeng.xyz/tags/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>11新特性</title>
    <link href="https://www.liuchanggeng.xyz/2020/08/30/CPP-Notes/C++11%E6%96%B0%E7%89%B9%E6%80%A7/"/>
    <id>https://www.liuchanggeng.xyz/2020/08/30/CPP-Notes/C++11%E6%96%B0%E7%89%B9%E6%80%A7/</id>
    <published>2020-08-30T07:56:00.000Z</published>
    <updated>2020-11-16T09:16:48.547Z</updated>
    
    <content type="html"><![CDATA[<h3 id="c11新特性"><a class="markdownIt-Anchor" href="#c11新特性"></a> C++11新特性</h3><h4 id="右值引用"><a class="markdownIt-Anchor" href="#右值引用"></a> 右值引用</h4>]]></content>
    
    
      
      
    <summary type="html">&lt;h3 id=&quot;c11新特性&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#c11新特性&quot;&gt;&lt;/a&gt; C++11新特性&lt;/h3&gt;
&lt;h4 id=&quot;右值引用&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#右值引用&quot;&gt;&lt;/a&gt; </summary>
      
    
    
    
    <category term="C/C++" scheme="https://www.liuchanggeng.xyz/categories/C-C/"/>
    
    
    <category term="学习笔记" scheme="https://www.liuchanggeng.xyz/tags/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>STL-侯捷</title>
    <link href="https://www.liuchanggeng.xyz/2020/08/29/CPP-Notes/%E4%BE%AF%E6%8D%B7STL/"/>
    <id>https://www.liuchanggeng.xyz/2020/08/29/CPP-Notes/%E4%BE%AF%E6%8D%B7STL/</id>
    <published>2020-08-29T11:56:00.000Z</published>
    <updated>2020-11-16T09:10:14.204Z</updated>
    
    <content type="html"><![CDATA[<h2 id="stl"><a class="markdownIt-Anchor" href="#stl"></a> STL</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;iterator&gt;&lt;functional&gt;&lt;vector&gt;&lt;deque&gt;</span><br><span class="line">&lt;list&gt;&lt;queue&gt;&lt;stack&gt;&lt;set&gt;</span><br><span class="line">&lt;map&gt;&lt;algorithm&gt;&lt;numeric&gt;&lt;memory&gt;</span><br><span class="line">&lt;utility&gt;</span><br></pre></td></tr></table></figure><ul><li>6大部件：<br />STL可分为容器(containers)、迭代器(iterators)、空间配置器(allocator)、配接器(adapters)、算法(algorithms)、仿函数(functors)六个部分。<br />最常用的是容器和算法，在使用算法时，不需要考虑内存的分配与释放，这是由分配器完成的，算法通过迭代器操作于容器。<br /><img src="https://lcg-pic-tencent-1258286866.cos.ap-chengdu.myqcloud.com/a%5Cb%5C20200817124355_fce2e96d3a59375565f5696963afb156.png" alt="a\b\20200817124355_fce2e96d3a59375565f5696963afb156.png" /><br /><img src="https://lcg-pic-tencent-1258286866.cos.ap-chengdu.myqcloud.com/a%5Cb%5C20200818004218_e3676769b32dfa2aca682695d66ba25c.png" alt="a\b\20200818004218_e3676769b32dfa2aca682695d66ba25c.png" /><br /><img src="https://lcg-pic-tencent-1258286866.cos.ap-chengdu.myqcloud.com/a%5Cb%5C20200817125333_37a3139802fa130488b4fcf45538a2bc.png" alt="a\b\20200817125333_37a3139802fa130488b4fcf45538a2bc.png" /><br />迭代器时前闭后开区间，[)，.end()指向最后一个元素下一个元素，迭代器是泛化的指针。</li></ul><h3 id="容器分类"><a class="markdownIt-Anchor" href="#容器分类"></a> 容器分类</h3><ul><li>序列式的：</li><li>关联式容器：可用来快速查找，红黑树实现，set,map,multiset,multimap</li><li>不定序容器：也可以认为是关联式的，unordered_set/unordered_map/unordered_multiset/unordered_multimap/<br /><img src="https://lcg-pic-tencent-1258286866.cos.ap-chengdu.myqcloud.com/a%5Cb%5C20200817131907_7d2cb3620f54b17769845213520ef81b.png" alt="a\b\20200817131907_7d2cb3620f54b17769845213520ef81b.png" /><br /><img src="https://lcg-pic-tencent-1258286866.cos.ap-chengdu.myqcloud.com/a%5Cb%5C20200817131929_fd5d64f974a4689d49a4dc8b2a300d28.png" alt="a\b\20200817131929_fd5d64f974a4689d49a4dc8b2a300d28.png" /></li></ul><p>如果标准库自己提供sort，优先用自己的。</p><ul><li>slist: include&lt;ext\slist&gt;和forward list相同，forward list是标准库中的，slist是早期的</li></ul><p><strong>deque</strong><br />分段连续，前后可扩充。<br /><img src="https://lcg-pic-tencent-1258286866.cos.ap-chengdu.myqcloud.com/a%5Cb%5C20200817151048_9308e327eaca1b987a3618501c9ddbd3.png" alt="a\b\20200817151048_9308e327eaca1b987a3618501c9ddbd3.png" /></p><h3 id="模板"><a class="markdownIt-Anchor" href="#模板"></a> 模板</h3><p><a href="https://www.cnblogs.com/shines77/p/3179022.html">模板优缺点</a><br />面向对象是数据和方法放一起。<br />泛型是数据和方法分开。（通过接口传数据，如algorithm中的迭代器）<br /><strong>模板分类</strong></p><ul><li>函数模板:调用时可以不显示指定类型，模板可以重载</li><li>类模板：必须显示指定类型</li><li>成员模板(不常用)</li></ul><p>类模板里面有全特化和偏特化<br />偏特化有个数上的偏，也有范围上的偏</p><p>全特化，为指定类型执行特殊的程序，优化算法。<br />注意开头是</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;&gt;</span><br></pre></td></tr></table></figure><p><img src="https://lcg-pic-tencent-1258286866.cos.ap-chengdu.myqcloud.com/a%5Cb%5C20200817163222_8d672da9b8ea60f36cbee03abb1241ad.png" alt="a\b\20200817163222_8d672da9b8ea60f36cbee03abb1241ad.png" /><br />偏特化<br /><img src="https://lcg-pic-tencent-1258286866.cos.ap-chengdu.myqcloud.com/a%5Cb%5C20200817163555_95257572ff660612061fddcbd5199c0b.png" alt="a\b\20200817163555_95257572ff660612061fddcbd5199c0b.png" /></p><h3 id="默认的分配器allocator"><a class="markdownIt-Anchor" href="#默认的分配器allocator"></a> 默认的分配器allocator</h3><p>也可以自定义</p><h3 id="容器-分类"><a class="markdownIt-Anchor" href="#容器-分类"></a> 容器 分类</h3><p><img src="https://lcg-pic-tencent-1258286866.cos.ap-chengdu.myqcloud.com/a%5Cb%5C20200817164249_faf4962508cb1863f7a0b58847b43fca.png" alt="a\b\20200817164249_faf4962508cb1863f7a0b58847b43fca.png" /></p><h3 id="迭代器的设计原则"><a class="markdownIt-Anchor" href="#迭代器的设计原则"></a> 迭代器的设计原则</h3><p>iterator_traits 萃取<br />iterator有5种associated types相当于迭代器的属性，想用迭代器时使用方法要根据迭代器的这几个特性设计，如algorithm调用迭代器时需要知道这些特性。<br /><img src="https://lcg-pic-tencent-1258286866.cos.ap-chengdu.myqcloud.com/a%5Cb%5C20200819093520_8553ddf993c6ac34424b013193790bc7.png" alt="a\b\20200819093520_8553ddf993c6ac34424b013193790bc7.png" /></p><p>iterator_category 单双向<br />value_type 容器的值类型<br />pointer 暂时未用<br />reference 暂时未用<br />difference_type 用来表示两个迭代器之间的距离</p><p>algorithm如果传进来的是指针(退化的迭代器)<br />则通过偏特化让算法知道这是指针。<br /><img src="https://lcg-pic-tencent-1258286866.cos.ap-chengdu.myqcloud.com/a%5Cb%5C20200819094239_a6693874fbad7eb7c8bf287e6e6433c0.png" alt="a\b\20200819094239_a6693874fbad7eb7c8bf287e6e6433c0.png" /></p><h4 id="容器rb_tree"><a class="markdownIt-Anchor" href="#容器rb_tree"></a> 容器rb_tree</h4><p><img src="https://lcg-pic-tencent-1258286866.cos.ap-chengdu.myqcloud.com/a%5Cb%5C20200819105346_78a2943cf3f1a1ef5523a2140ff55b2d.png" alt="a\b\20200819105346_78a2943cf3f1a1ef5523a2140ff55b2d.png" /></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;stl&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#stl&quot;&gt;&lt;/a&gt; STL&lt;/h2&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span</summary>
      
    
    
    
    <category term="C/C++" scheme="https://www.liuchanggeng.xyz/categories/C-C/"/>
    
    
    <category term="学习笔记" scheme="https://www.liuchanggeng.xyz/tags/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>类多态</title>
    <link href="https://www.liuchanggeng.xyz/2020/08/29/CPP-Notes/%E7%B1%BB%E5%A4%9A%E6%80%81/"/>
    <id>https://www.liuchanggeng.xyz/2020/08/29/CPP-Notes/%E7%B1%BB%E5%A4%9A%E6%80%81/</id>
    <published>2020-08-29T06:46:00.000Z</published>
    <updated>2020-11-16T09:13:31.328Z</updated>
    
    <content type="html"><![CDATA[<h3 id="类多态"><a class="markdownIt-Anchor" href="#类多态"></a> 类多态</h3><h3 id="参考资料"><a class="markdownIt-Anchor" href="#参考资料"></a> 参考资料</h3><p><a href="https://www.cnblogs.com/mhjerry/archive/2012/12/16/2820895.html">虚函数表</a></p><p>多态（Polymorphism）按字面的意思就是“多种状态”。在面向对象语言中，接口的多种不同的实现方式即为多态。引用Charlie Calverts对多态的描述——多态性是允许你将父对象设置成为一个或更多的他的子对象相等的技术，赋值之后，父对象就可以根据当前赋值给它的子对象的特性以不同的方式运作（摘自“Delphi4 编程技术内幕”）。简单的说，就是一句话：<strong>允许将子类类型的指针赋值给父类类型的指针。多态性在Object Pascal和C++中都是通过虚函数实现的。</strong></p><h4 id="override"><a class="markdownIt-Anchor" href="#override"></a> override</h4><p>覆盖,也可以说是重写，但和overwrite重写不一样，是翻译的问题，直接说英文。</p><ul><li>作为关键字，放在<strong>虚函数</strong>后面(形参列表后面，或者在const成员函数的const后面，或者是在引用成员函数的引用限定符&amp;后面)</li><li>覆盖要和虚函数的形参列表相同，不同的话就是一个独立的函数和基类没关系。但是一般不这么用，多数情况下是写错了才这么用的，这时编译器很难检测出来，为了方便调试，C++11 引入override关键字，当有这个关键字并且形参列表不同时，编译器会报错。</li></ul><h4 id="finalc11"><a class="markdownIt-Anchor" href="#finalc11"></a> final(C++11)</h4><ul><li>放在类名后面，则该类不能作为基类，避免继承。</li><li>放在<strong>虚函数</strong>后面，则派生类不能override此函数(不能放在非虚函数后面)</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> CLASS_TEST_H</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> CLASS_TEST_H</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">A():a(<span class="number">0</span>),b(<span class="number">0</span>) &#123;&#125;;</span><br><span class="line">~A() &#123;&#125;;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">func1</span><span class="params">(<span class="keyword">int</span> a)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">func1</span><span class="params">(<span class="keyword">double</span> a)</span></span>;<span class="comment">//重载</span></span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">func2</span><span class="params">(<span class="keyword">int</span> a)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">func3</span><span class="params">(<span class="keyword">int</span> a)</span></span>;</span><br><span class="line"><span class="comment">//virtual void func4(int a)=0;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line"><span class="keyword">int</span> a;</span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line"><span class="keyword">int</span> b;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A2</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">A2() :a(<span class="number">0</span>), b(<span class="number">0</span>) &#123;&#125;;</span><br><span class="line">~A2() &#123;&#125;;</span><br><span class="line"><span class="comment">//void func1(int a);</span></span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">func1</span><span class="params">(<span class="keyword">int</span> a)</span></span>=<span class="number">0</span>;<span class="comment">//纯虚函数</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line"><span class="keyword">int</span> a;</span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line"><span class="keyword">int</span> b;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span>:</span><span class="keyword">public</span> A</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">func1</span><span class="params">()</span></span>;<span class="comment">//重写/隐藏。非虚函数</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">func1</span><span class="params">(<span class="keyword">int</span> a)</span></span>;<span class="comment">//重写/隐藏</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">func3</span><span class="params">(<span class="keyword">int</span> a)</span> <span class="keyword">override</span></span>;<span class="comment">//覆盖，编译器一般翻译成重写(但不是overwrite)，override,也是虚函数(隐式的)，也可以在前面加上virtual(显式)</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">func3</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span></span>;<span class="comment">//这是一个独立的函数，和基类没关系，</span></span><br><span class="line"><span class="comment">//不是覆盖(因为形参列表不同，如果加上overrid关键字编译器会报错)，也不是重写(重写是基类的非虚)</span></span><br><span class="line">;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B2</span> :</span><span class="keyword">public</span> A2</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">B2():A2()&#123;&#125;;</span><br><span class="line">~B2();</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">func1</span><span class="params">(<span class="keyword">int</span> a)</span></span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span> <span class="comment">// !CLASS_TEST_H</span></span></span><br></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;class_test.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="comment">//class A</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">A::func1</span><span class="params">(<span class="keyword">int</span> a)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;class A:func1(int)&quot;</span>&lt;&lt;a &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">A::func1</span><span class="params">(<span class="keyword">double</span> a)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;class A:func1(double)&quot;</span> &lt;&lt; a &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">A::func2</span><span class="params">(<span class="keyword">int</span> a)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;class A virtual func2(int a)&quot;</span> &lt;&lt; a &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">A::func3</span><span class="params">(<span class="keyword">int</span> a)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;class A virtual func3(int a)&quot;</span> &lt;&lt; a &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//class A2</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">A2::func1</span><span class="params">(<span class="keyword">int</span> a)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;class A2:func1(int a)&quot;</span> &lt;&lt; a &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//class B</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">B::func1</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;class B:func1&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">B::func1</span><span class="params">(<span class="keyword">int</span> a)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;class B:func1(int)&quot;</span> &lt;&lt;a &lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">B::func3</span><span class="params">(<span class="keyword">int</span> a)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;class B:func3(int a)&quot;</span> &lt;&lt; a&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">B::func3</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;class B:func3(int a, int b)&quot;</span> &lt;&lt; a &lt;&lt; b &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">B2::func1</span><span class="params">(<span class="keyword">int</span> a)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;class B2:func1(int a)&quot;</span> &lt;&lt; a &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&quot;class_test.h&quot;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    A clsA;</span><br><span class="line">    clsA.func1(<span class="number">1</span>);</span><br><span class="line">    clsA.func1(<span class="number">1.1</span>);<span class="comment">//重载</span></span><br><span class="line">    B claB;</span><br><span class="line">    claB.func1();</span><br><span class="line">    claB.func1(<span class="number">2</span>);</span><br><span class="line">    claB.A::func1(<span class="number">2</span>);<span class="comment">//通过作用域改变调用函数</span></span><br><span class="line">    claB.func2(<span class="number">3</span>);<span class="comment">//B中没有func2</span></span><br><span class="line">    claB.func3(<span class="number">3</span>);<span class="comment">//B中有func3，覆盖</span></span><br><span class="line">    claB.A::func3(<span class="number">3</span>);<span class="comment">//通过作用域改变调用函数</span></span><br><span class="line">    claB.func3(<span class="number">3</span>,<span class="number">4</span>);<span class="comment">//独立的函数</span></span><br><span class="line">    A *claAB=<span class="keyword">new</span> B;</span><br><span class="line">    claAB = &amp;claB;<span class="comment">//子类指针可以赋给父类指针，反之不能</span></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    导致错误输出的原因是，调用函数 func1() 被编译器设置为基类中的版本，</span></span><br><span class="line"><span class="comment">    这就是所谓的静态多态，或静态链接 - 函数调用在程序执行前就准备好了。</span></span><br><span class="line"><span class="comment">    有时候这也被称为早绑定，因为 func1()  函数在程序编译期间就已经设置好了。*/</span></span><br><span class="line">    claAB-&gt;func1(<span class="number">4</span>);<span class="comment">//静态多态，静态链接，早绑定</span></span><br><span class="line">    ((B*)claAB)-&gt;func1(<span class="number">5</span>);</span><br><span class="line">    ((B*)claAB)-&gt;func2(<span class="number">5</span>);<span class="comment">//B中没有func2</span></span><br><span class="line">    claAB-&gt;func3(<span class="number">6</span>);<span class="comment">//动态多态，动态链接，后绑定</span></span><br><span class="line"></span><br><span class="line">    B* pclaB;</span><br><span class="line">    pclaB = &amp;claB;</span><br><span class="line">    pclaB-&gt;func1(<span class="number">5</span>);<span class="comment">//重写，overwrite，隐藏了基类函数，注意和早绑定的区别</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">//A2 claA2;//错误，不能使用纯虚拟函数的对象</span></span><br><span class="line">   <span class="comment">// A2* pclasA2 = new A2();//错误，不能使用纯虚拟函数的对象</span></span><br><span class="line">    A2* pclasA2 = <span class="keyword">new</span> B2();<span class="comment">//子类指针赋值给基类</span></span><br><span class="line">    pclasA2-&gt;func1(<span class="number">1</span>);</span><br><span class="line">    <span class="comment">//B2 claB2;</span></span><br><span class="line">    B2* pclaB2 = <span class="keyword">new</span> B2();</span><br><span class="line">    pclaB2-&gt;func1(<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="typeid"><a class="markdownIt-Anchor" href="#typeid"></a> typeid</h4><p>在c++中，typeid用于返回指针或引用所指对象的实际类型。<br />typeid是操作符，不是函数.<br />对非引用类型，typeid是在编译时期识别的，只有引用类型才会在运行时识别。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> a;</span><br><span class="line"><span class="keyword">const</span> type_info &amp; info=<span class="keyword">typeid</span>(a);</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; info.name() &lt;&lt; <span class="built_in">endl</span>;<span class="comment">//类型的名称</span></span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; info.raw_name() &lt;&lt; <span class="built_in">endl</span>;<span class="comment">//名字编码（Name Mangling）算法产生的新名称</span></span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; info.hash_code() &lt;&lt; <span class="built_in">endl</span>;<span class="comment">//返回当前类型对应的 hash 值</span></span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">int</span><br><span class="line">.H</span><br><span class="line">3440116983</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h3 id=&quot;类多态&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#类多态&quot;&gt;&lt;/a&gt; 类多态&lt;/h3&gt;
&lt;h3 id=&quot;参考资料&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#参考资料&quot;&gt;&lt;/a&gt; 参考资料&lt;/h3&gt;
&lt;</summary>
      
    
    
    
    <category term="C/C++" scheme="https://www.liuchanggeng.xyz/categories/C-C/"/>
    
    
    <category term="学习笔记" scheme="https://www.liuchanggeng.xyz/tags/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>智能指针</title>
    <link href="https://www.liuchanggeng.xyz/2020/08/27/CPP-Notes/%E6%99%BA%E8%83%BD%E6%8C%87%E9%92%88/"/>
    <id>https://www.liuchanggeng.xyz/2020/08/27/CPP-Notes/%E6%99%BA%E8%83%BD%E6%8C%87%E9%92%88/</id>
    <published>2020-08-27T03:30:00.000Z</published>
    <updated>2020-11-16T09:16:01.710Z</updated>
    
    <content type="html"><![CDATA[<h3 id="智能指针"><a class="markdownIt-Anchor" href="#智能指针"></a> 智能指针</h3><h4 id="参考资料"><a class="markdownIt-Anchor" href="#参考资料"></a> 参考资料</h4><ul><li><a href="https://www.cnblogs.com/wxquare/p/4759020.html">C++11中智能指针的原理、使用、实现</a></li></ul><p><strong>使用</strong><br />智能指针在C++11版本之后提供，包含在头文件<br />&lt;memory&gt;中，shared_ptr、unique_ptr、weak_ptr(伴随类)</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h3 id=&quot;智能指针&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#智能指针&quot;&gt;&lt;/a&gt; 智能指针&lt;/h3&gt;
&lt;h4 id=&quot;参考资料&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#参考资料&quot;&gt;&lt;/a&gt; 参考资料&lt;/h4</summary>
      
    
    
    
    <category term="C/C++" scheme="https://www.liuchanggeng.xyz/categories/C-C/"/>
    
    
    <category term="学习笔记" scheme="https://www.liuchanggeng.xyz/tags/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>STL-笔记</title>
    <link href="https://www.liuchanggeng.xyz/2020/08/26/CPP-Notes/STLNotes/"/>
    <id>https://www.liuchanggeng.xyz/2020/08/26/CPP-Notes/STLNotes/</id>
    <published>2020-08-26T03:05:00.000Z</published>
    <updated>2020-11-16T09:09:53.248Z</updated>
    
    <content type="html"><![CDATA[<h3 id="参考"><a class="markdownIt-Anchor" href="#参考"></a> 参考</h3><p><a href="http://www.cplusplus.com/reference/stl/">http://www.cplusplus.com/reference/stl/</a></p><h3 id="分类"><a class="markdownIt-Anchor" href="#分类"></a> 分类</h3><ul><li>顺序容器</li><li>关联容器<ul><li>有序容器（红黑树）</li><li>无序容器（哈希表）</li></ul></li></ul><h3 id="通用接口"><a class="markdownIt-Anchor" href="#通用接口"></a> 通用接口</h3><h4 id="类型别名"><a class="markdownIt-Anchor" href="#类型别名"></a> 类型别名</h4><h5 id="iterator"><a class="markdownIt-Anchor" href="#iterator"></a> iterator</h5><h5 id="const_iterator"><a class="markdownIt-Anchor" href="#const_iterator"></a> const_iterator</h5><h5 id="size_type"><a class="markdownIt-Anchor" href="#size_type"></a> size_type</h5><h5 id="difference_type"><a class="markdownIt-Anchor" href="#difference_type"></a> difference_type</h5><h5 id="value_type"><a class="markdownIt-Anchor" href="#value_type"></a> value_type</h5><h5 id="reference"><a class="markdownIt-Anchor" href="#reference"></a> reference</h5><h5 id="const_reference"><a class="markdownIt-Anchor" href="#const_reference"></a> const_reference</h5><h4 id="构造函数"><a class="markdownIt-Anchor" href="#构造函数"></a> 构造函数</h4><h4 id="赋值"><a class="markdownIt-Anchor" href="#赋值"></a> 赋值</h4><h5 id="assign仅顺序容器"><a class="markdownIt-Anchor" href="#assign仅顺序容器"></a> assign(仅顺序容器)</h5><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">a.assign(it1,it2);<span class="comment">//给定迭代器范围进行赋值</span></span><br><span class="line">a.assign(&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>&#125;);<span class="comment">//列表赋值</span></span><br><span class="line">a.assign(n,t);<span class="comment">//n个t</span></span><br></pre></td></tr></table></figure><p>assign允许从一个不同但相容的类型赋值。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">list</span>&lt;<span class="built_in">string</span>&gt; names;</span><br><span class="line"> <span class="built_in">vector</span>&lt;<span class="keyword">const</span> <span class="keyword">char</span>*&gt; old;</span><br><span class="line"> <span class="keyword">char</span>* tmp = <span class="keyword">new</span> <span class="keyword">char</span>[<span class="number">3</span>];</span><br><span class="line"> tmp[<span class="number">0</span>] = <span class="string">&#x27;7&#x27;</span>;</span><br><span class="line"> tmp[<span class="number">1</span>] = <span class="string">&#x27;8&#x27;</span>;</span><br><span class="line"> tmp[<span class="number">2</span>] = <span class="string">&#x27;\0&#x27;</span>;</span><br><span class="line"> <span class="keyword">char</span> tmp2[<span class="number">4</span>] = <span class="string">&quot;abc&quot;</span>;</span><br><span class="line"> <span class="comment">//names.push_back(&quot;123&quot;);</span></span><br><span class="line"> <span class="comment">//names.push_back(&quot;456&quot;);</span></span><br><span class="line"> old.push_back(tmp);</span><br><span class="line"> old.push_back(tmp2);</span><br><span class="line"></span><br><span class="line"> names.assign(old.cbegin(), old.cend());</span><br><span class="line"> <span class="keyword">for</span> (<span class="keyword">auto</span> i : names) <span class="built_in">cout</span> &lt;&lt; i &lt;&lt; <span class="string">&quot; &quot;</span>;<span class="comment">//78 abc</span></span><br><span class="line"> <span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br></pre></td></tr></table></figure><p>array的assign不能按上述用，a.assign(1)是把assign所有位置都变成1.</p><h5 id="swap"><a class="markdownIt-Anchor" href="#swap"></a> swap</h5><p>常数时间交换两个相同容器的内容。元素本身并未交换，只是交换了数据结构(比如迭代器的指向)<br />但是array特殊，相当于数组。会真正交换其元素。也不是常数时间。</p><p>对<code>string</code>调用swap会导致迭代器、引用和指针失效。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="built_in">string</span> <span class="title">s1</span><span class="params">(<span class="string">&quot;123&quot;</span>)</span></span>;</span><br><span class="line"><span class="function"><span class="built_in">string</span> <span class="title">s2</span><span class="params">(<span class="string">&quot;456&quot;</span>)</span></span>;</span><br><span class="line"><span class="built_in">string</span>::iterator it0 = s1.begin();</span><br><span class="line">swap(s1, s2);</span><br><span class="line"><span class="comment">//s1.swap(s2);</span></span><br><span class="line"><span class="keyword">auto</span> it1 = s1.begin();</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; *it0 &lt;&lt; <span class="built_in">endl</span>;<span class="comment">//迭代器失效</span></span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; *it1 &lt;&lt; <span class="built_in">endl</span>;<span class="comment">//4</span></span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; s1 &lt;&lt; <span class="built_in">endl</span>;<span class="comment">//456</span></span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; s2 &lt;&lt; <span class="built_in">endl</span>;<span class="comment">//123</span></span><br></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; v1 = &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>&#125;;</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; v2 = &#123;<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">auto</span> it0 = v1.begin();</span><br><span class="line">swap(v1, v2);</span><br><span class="line"><span class="keyword">auto</span> it1 = v1.begin();</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; *it0 &lt;&lt; <span class="built_in">endl</span>;<span class="comment">//未失效，1</span></span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; *it1 &lt;&lt; <span class="built_in">endl</span>;<span class="comment">//4</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">auto</span> i : v1)<span class="built_in">cout</span> &lt;&lt; i &lt;&lt; <span class="string">&quot; &quot;</span>; <span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;<span class="comment">//4567</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">auto</span> i : v2)<span class="built_in">cout</span> &lt;&lt; i &lt;&lt; <span class="string">&quot; &quot;</span>; <span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;<span class="comment">//123</span></span><br></pre></td></tr></table></figure><h4 id="大小"><a class="markdownIt-Anchor" href="#大小"></a> 大小</h4><h5 id="empty"><a class="markdownIt-Anchor" href="#empty"></a> empty</h5><h5 id="size"><a class="markdownIt-Anchor" href="#size"></a> size</h5><p>不支持forward_list</p><h5 id="max_size"><a class="markdownIt-Anchor" href="#max_size"></a> max_size</h5><h5 id="capacityreserceshrink_to_fit"><a class="markdownIt-Anchor" href="#capacityreserceshrink_to_fit"></a> capacity,reserce,shrink_to_fit</h5><p>capacity,reserve只适用于vector和string<br />reserve永远不会减少容量，只能用shrink_to_fit减少。<br />shrink_to_fit将capacity减少为于size相同大小，并<strong>请求</strong>将超出当前大小的多余内存退回给操作系统，但只是一个请求，并不能保证一定退还内存，这是操作系统的事。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;a;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">100</span>; ++i) a.push_back(i);</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; a.size() &lt;&lt; <span class="built_in">endl</span>;<span class="comment">//100</span></span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; a.capacity() &lt;&lt; <span class="built_in">endl</span>;<span class="comment">//141</span></span><br><span class="line">a.shrink_to_fit();</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; a.size() &lt;&lt; <span class="built_in">endl</span>;<span class="comment">//100</span></span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; a.capacity() &lt;&lt; <span class="built_in">endl</span>;<span class="comment">//100</span></span><br></pre></td></tr></table></figure><p>每次扩容当大小超过capacity时，都要重新分配大小，将原有的元素移到新位置，释放旧内存，vector的扩张操作通常比list和deque快。<br />扩容分配策略遵循原则：通过一个初始为空的vector上调用n次push_back()来创建n个元素所花费的时间不能超过n的常数倍。</p><h4 id="获取迭代器"><a class="markdownIt-Anchor" href="#获取迭代器"></a> 获取迭代器</h4><h4 id="反向容器的额外成员"><a class="markdownIt-Anchor" href="#反向容器的额外成员"></a> 反向容器的额外成员</h4><h4 id="添加"><a class="markdownIt-Anchor" href="#添加"></a> 添加</h4><p>vector,deuqe,string等插入元素会使迭代器，指针，引用失效。<br />在vector的尾部以外或者deque的首尾以外任何地方添加元素，都<strong>可能</strong>引起整个对象存储空间的重新分配。重新分配内存，将元素从旧的地址空格键移动到新的空间中。<br />forward_list不支持push_back和empace_back,有自己专属的emplace和insert</p><h5 id="push_backpush_frontpush"><a class="markdownIt-Anchor" href="#push_backpush_frontpush"></a> push_back,push_front,push</h5><p>传进去的是对象的一个拷贝，而不是对象本身。</p><h5 id="emplace_backemplace_frontemplace"><a class="markdownIt-Anchor" href="#emplace_backemplace_frontemplace"></a> emplace_back,emplace_front,emplace</h5><p>emplace_back,emplace_front,emplace分别对应push_back,push_front和insert操作。<br />区别是当我们调用emplace成员函数时，是将参数传递给元素类型的<strong>构造函数</strong>，emplace成员使用这些参数在容器管理的内存空间中直接构造元素。而push_back()则会创建一个局部临时对象，并将其压入容器。</p><h5 id="insert"><a class="markdownIt-Anchor" href="#insert"></a> insert</h5><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; a = &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>&#125;;</span><br><span class="line">  <span class="keyword">auto</span> iter = a.begin();</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; ++i)</span><br><span class="line">  &#123;</span><br><span class="line">      iter = a.insert(iter, i);<span class="comment">//反复插元素，返回的是新插入的位置的迭代器</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">auto</span> i : a)<span class="built_in">cout</span> &lt;&lt; i &lt;&lt; <span class="string">&quot; &quot;</span>; <span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">  <span class="comment">//9 8 7 6 5 4 3 2 1 0 1 2 3</span></span><br></pre></td></tr></table></figure><h4 id="访问"><a class="markdownIt-Anchor" href="#访问"></a> 访问</h4><p>返回的是引用</p><h5 id="at"><a class="markdownIt-Anchor" href="#at"></a> at</h5><p>只适合vector，deque，string，array<br />越界则抛出<code>out_of_range</code>异常。</p><h5 id=""><a class="markdownIt-Anchor" href="#"></a> []</h5><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; a = &#123; <span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span> &#125;;</span><br><span class="line"><span class="keyword">auto</span> atmp = a[<span class="number">1</span>];</span><br><span class="line">atmp = <span class="number">10</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">auto</span> i : a)<span class="built_in">cout</span> &lt;&lt; i &lt;&lt; <span class="string">&quot; &quot;</span>; <span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;<span class="comment">//1 10 3</span></span><br><span class="line"><span class="keyword">auto</span>&amp; atmp2 = a[<span class="number">1</span>];</span><br><span class="line">atmp2 = <span class="number">10</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">auto</span> i : a)<span class="built_in">cout</span> &lt;&lt; i &lt;&lt; <span class="string">&quot; &quot;</span>; <span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;<span class="comment">// 1 2 3</span></span><br></pre></td></tr></table></figure><h3 id="vector"><a class="markdownIt-Anchor" href="#vector"></a> vector</h3><h4 id="初始化"><a class="markdownIt-Anchor" href="#初始化"></a> 初始化</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;a(<span class="number">10</span>);</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;b(<span class="number">10</span>,<span class="number">1</span>);</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;c=&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>&#125;;</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;d(&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>&#125;);</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;e(c);</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;f(c.begin(), c.begin() + <span class="number">6</span>);</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;g(&amp;c[<span class="number">0</span>], &amp;c[<span class="number">5</span>]+<span class="number">1</span>);</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;e(c,c+<span class="number">6</span>);</span><br></pre></td></tr></table></figure><h4 id="各接口"><a class="markdownIt-Anchor" href="#各接口"></a> 各接口</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;a=&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>&#125;;</span><br><span class="line">a.push_back();</span><br><span class="line">a.pop_back();</span><br><span class="line">a.emplace_back();</span><br><span class="line">a.empty();</span><br><span class="line">a.size();</span><br><span class="line">b.max_size();<span class="comment">//可保存的最大元素数目</span></span><br><span class="line">a.capacity();</span><br><span class="line">a.resize(<span class="number">100</span>);</span><br><span class="line">a.reserve(<span class="number">100</span>);</span><br><span class="line">a.assign();</span><br><span class="line">a[<span class="number">1</span>];</span><br><span class="line">a.at(<span class="number">1</span>);</span><br><span class="line">a.data();</span><br><span class="line">a.clear();</span><br><span class="line">a.earse();</span><br><span class="line">a.swap(b);;</span><br></pre></td></tr></table></figure><p><strong>两种访问方式：</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">vector</span>::at()<span class="comment">//进行边界检查，效率低于[]，超出边界会抛出exception。</span></span><br><span class="line"><span class="built_in">vector</span>::<span class="keyword">operator</span>[]<span class="comment">//可能月越界，访问效率高</span></span><br></pre></td></tr></table></figure><p>在release模式下,[]越界不会报错，at()会触发异常。</p><p><strong>删除</strong><br />clear(),pop_back(),erase()</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">cmp</span><span class="params">(<span class="keyword">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (x &lt; <span class="number">5</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; b;</span><br><span class="line">    b.push_back(<span class="number">1</span>);</span><br><span class="line">    b.push_back(<span class="number">2</span>);</span><br><span class="line">    b.push_back(<span class="number">3</span>);</span><br><span class="line">    b.push_back(<span class="number">4</span>);</span><br><span class="line">    b.push_back(<span class="number">5</span>);</span><br><span class="line">    b.push_back(<span class="number">6</span>);</span><br><span class="line">    <span class="keyword">auto</span> it = b.begin();</span><br><span class="line">    b.erase(it + <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> i : b) <span class="built_in">cout</span> &lt;&lt; i &lt;&lt; <span class="string">&quot;  &quot;</span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">   <span class="comment">// auto it2 = remove(b.begin(), b.end(), 5);</span></span><br><span class="line">    <span class="keyword">auto</span> it2 = remove_if(b.begin(), b.end(), cmp);</span><br><span class="line">    b.erase(it2,b.end());</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> i : b) <span class="built_in">cout</span> &lt;&lt; i &lt;&lt; <span class="string">&quot;  &quot;</span>;</span><br><span class="line">    b.clear();</span><br></pre></td></tr></table></figure><p>vector&lt;bool&gt;较为特殊：可以参考<a href="http://www.cplusplus.com/reference/vector/vector-bool/">http://www.cplusplus.com/reference/vector/vector-bool/</a><br />还有bitset(位图)和valarray(支持高速运算的数组)</p><h4 id="emplace"><a class="markdownIt-Anchor" href="#emplace"></a> emplace</h4><h5 id="参考资料"><a class="markdownIt-Anchor" href="#参考资料"></a> 参考资料</h5><ul><li><a href="https://www.cnblogs.com/carsonzhu/p/5113213.html">emplace_back减少内存拷贝和移动</a></li></ul><p>C++11 起 push_back 需要分配新内存时一般都是把元素移动构造过去，而非复制构造。</p><p>在vector文件中debug push_back()和emplace_back()的源码。观察函数调用</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;map&gt;</span></span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Complicated</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> year;</span><br><span class="line"><span class="keyword">double</span> country;</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">string</span> name;</span><br><span class="line"></span><br><span class="line">Complicated(<span class="keyword">int</span> a, <span class="keyword">double</span> b, <span class="built_in">string</span> c) :year(a), country(b), name(c)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;is constucted&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Complicated(<span class="keyword">const</span> Complicated&amp; other) :year(other.year), country(other.country), name(<span class="built_in">std</span>::move(other.name))</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;is moved&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line">~Complicated()</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Deconstruction&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">std</span>::<span class="built_in">map</span>&lt;<span class="keyword">int</span>, Complicated&gt; m;</span><br><span class="line"><span class="keyword">int</span> anInt = <span class="number">4</span>;</span><br><span class="line"><span class="keyword">double</span> aDouble = <span class="number">5.0</span>;</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">string</span> aString = <span class="string">&quot;C++&quot;</span>;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;—insert--&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">m.insert(<span class="built_in">std</span>::<span class="built_in">make_pair</span>(<span class="number">4</span>, Complicated(anInt, aDouble, aString)));</span><br><span class="line"></span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;—emplace--&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="comment">// should be easier for the optimizer </span></span><br><span class="line">m.emplace(<span class="number">4</span>, Complicated(anInt, aDouble, aString));</span><br><span class="line"></span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;--emplace_back--&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="built_in">vector</span>&lt;Complicated&gt; v;</span><br><span class="line">v.emplace_back(anInt, aDouble, aString);</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;--两步push_back--&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="function">Complicated <span class="title">tmp</span><span class="params">(anInt, aDouble, aString)</span></span>;</span><br><span class="line"><span class="comment">//v.push_back(Complicated(anInt, aDouble, aString));</span></span><br><span class="line">v.push_back(tmp);</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;--一步push_back--&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">v.push_back(Complicated(anInt, aDouble, aString));</span><br></pre></td></tr></table></figure><h3 id="array"><a class="markdownIt-Anchor" href="#array"></a> array</h3><p>定义时，必须要指定类型和大小，底层有数组实现，所以和数组很像，但可以比数组功能强，如可以直接用<code>=</code>进行array之间的赋值。</p><ul><li>不支持assign</li><li>不支持列表赋值。</li></ul><h3 id="deque-双端队列"><a class="markdownIt-Anchor" href="#deque-双端队列"></a> deque 双端队列</h3><p>double-ended queue 的缩写，又称双端队列容器。<br />双端队列(deque) 连续存储的指向不同元素的指针所组成的数组<deque><br /><img src="https://lcg-pic-tencent-1258286866.cos.ap-chengdu.myqcloud.com/a%5Cb%5C20200817220411_59767566eb92da851fc640b1dff429e1.png" alt="a\b\20200817220411_59767566eb92da851fc640b1dff429e1.png" /><br />分段连续，然后串接</p><h3 id="list-双向链表"><a class="markdownIt-Anchor" href="#list-双向链表"></a> list 双向链表</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;list&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">TestList</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">list</span>&lt;<span class="keyword">int</span>&gt; l;</span><br><span class="line">    l.push_back(<span class="number">0</span>);</span><br><span class="line">    l.push_back(<span class="number">4</span>);</span><br><span class="line">    l.push_back(<span class="number">5</span>);</span><br><span class="line">    <span class="built_in">list</span>&lt;<span class="keyword">int</span>&gt; l2;</span><br><span class="line">    l2.push_back(<span class="number">1</span>);</span><br><span class="line">    l2.push_back(<span class="number">2</span>);</span><br><span class="line">    l2.push_back(<span class="number">3</span>);</span><br><span class="line">    <span class="keyword">auto</span> it = l.begin();</span><br><span class="line">    advance(it, <span class="number">1</span>);<span class="comment">//迭代器不能自增，所以想要得到特定位置迭代器，需要调用此函数</span></span><br><span class="line">    l.insert(it, l2.begin(), l2.end());</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> i : l)<span class="built_in">cout</span> &lt;&lt; i &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">list</span>&lt;<span class="keyword">int</span>&gt; l3 = &#123;<span class="number">-3</span>,<span class="number">-2</span>,<span class="number">-1</span>&#125;;</span><br><span class="line">    it = l.begin();</span><br><span class="line">    l.splice(it, l3);<span class="comment">//splice删除list的部分或全部元素，并拼接到另一个list的迭代器的位置处。</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> i:l) <span class="built_in">cout</span> &lt;&lt; i &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; l3.size() &lt;&lt; <span class="built_in">endl</span>;<span class="comment">//l3已经被清除</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://lcg-pic-tencent-1258286866.cos.ap-chengdu.myqcloud.com/a%5Cb%5C20200817225258_56d544eed39c72453f7da516d1773c17.png" alt="a\b\20200817225258_56d544eed39c72453f7da516d1773c17.png" /></p><p><img src="https://lcg-pic-tencent-1258286866.cos.ap-chengdu.myqcloud.com/a%5Cb%5C20200817225533_d18cb3e22e95d199a29049486e398058.png" alt="a\b\20200817225533_d18cb3e22e95d199a29049486e398058.png" /></p><h3 id="stack栈"><a class="markdownIt-Anchor" href="#stack栈"></a> stack栈</h3><p>先进后出<br /><img src="https://lcg-pic-tencent-1258286866.cos.ap-chengdu.myqcloud.com/a%5Cb%5C20200817231133_bd927e6909da8f2c5614791e05208251.png" alt="a\b\20200817231133_bd927e6909da8f2c5614791e05208251.png" /><br /><img src="https://lcg-pic-tencent-1258286866.cos.ap-chengdu.myqcloud.com/a%5Cb%5C20200817231357_1eb1348431614a72c7a003b0adc1d649.png" alt="a\b\20200817231357_1eb1348431614a72c7a003b0adc1d649.png" /></p><h3 id="queue"><a class="markdownIt-Anchor" href="#queue"></a> queue</h3><p>先进先出,底层结构：deque/list，没有迭代器</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;queue&gt;</span><br><span class="line">queue&lt;int&gt; q;</span><br><span class="line">q.push(1);</span><br><span class="line">q.pop();</span><br><span class="line">q.front();</span><br><span class="line">q.back();</span><br></pre></td></tr></table></figure><h3 id="forward_list"><a class="markdownIt-Anchor" href="#forward_list"></a> forward_list</h3><p>迭代器不支持（–）<br />不支持反向容器的额外成员</p><h3 id="setmultiset"><a class="markdownIt-Anchor" href="#setmultiset"></a> set/multiset</h3><p><img src="https://lcg-pic-tencent-1258286866.cos.ap-chengdu.myqcloud.com/a%5Cb%5C20200819110908_5fb92fb48141f02425b03a417c3d5d17.png" alt="a\b\20200819110908_5fb92fb48141f02425b03a417c3d5d17.png" /></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt; <span class="class"><span class="keyword">class</span> <span class="title">T</span>,                        // 键 <span class="title">key</span> 和值 <span class="title">value</span> 的类型</span></span><br><span class="line"><span class="class">           <span class="keyword">class</span> <span class="title">Compare</span> =</span> less&lt;T&gt;,        <span class="comment">// 指定 set 容器内部的排序规则</span></span><br><span class="line">           <span class="class"><span class="keyword">class</span> <span class="title">Alloc</span> =</span> allocator&lt;T&gt;      <span class="comment">// 指定分配器对象的类型</span></span><br><span class="line">           &gt; <span class="class"><span class="keyword">class</span> <span class="title">set</span>;</span></span><br></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">set</span>&lt;<span class="keyword">int</span>&gt; set1 = &#123;<span class="number">4</span>,<span class="number">3</span>,<span class="number">2</span>,<span class="number">1</span>&#125;;</span><br><span class="line">set1.insert(<span class="number">5</span>);</span><br><span class="line">set1.emplace(<span class="number">6</span>);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i : set1)  <span class="built_in">cout</span> &lt;&lt; i &lt;&lt; <span class="string">&quot; &quot;</span>; <span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="keyword">auto</span> it = set1.find(<span class="number">3</span>);</span><br><span class="line">it++; <span class="built_in">cout</span> &lt;&lt; *it &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">it = set1.find(<span class="number">0</span>);</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt;<span class="built_in">std</span>::boolalpha&lt;&lt; (it==set1.end()) &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">it = set1.lower_bound(<span class="number">3</span>); <span class="built_in">cout</span> &lt;&lt; *it &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">it = set1.upper_bound(<span class="number">3</span>); <span class="built_in">cout</span> &lt;&lt; *it &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="keyword">auto</span> it2 = set1.equal_range(<span class="number">3</span>); <span class="built_in">cout</span> &lt;&lt; *it2.first &lt;&lt;<span class="string">&quot; &quot;</span>&lt;&lt;*it2.second&lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; set1.size() &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">it = set1.find(<span class="number">1</span>);</span><br><span class="line">set1.erase(it);</span><br><span class="line">set1.erase(<span class="number">2</span>);</span><br><span class="line">set1.erase(<span class="number">100</span>);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i : set1)  <span class="built_in">cout</span> &lt;&lt; i &lt;&lt; <span class="string">&quot; &quot;</span>; <span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">1 2 3 4 5 6</span><br><span class="line">4</span><br><span class="line">true</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">3 4</span><br><span class="line">6</span><br><span class="line">3 4 5 6</span><br></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">multiset</span>&lt;<span class="keyword">int</span>&gt; mset1;</span><br><span class="line">mset1.insert(<span class="number">4</span>);</span><br><span class="line">mset1.insert(<span class="number">3</span>);</span><br><span class="line">mset1.insert(<span class="number">2</span>);</span><br><span class="line">mset1.insert(<span class="number">2</span>);</span><br><span class="line">mset1.insert(<span class="number">2</span>);</span><br><span class="line">mset1.insert(<span class="number">5</span>);</span><br><span class="line">mset1.emplace(<span class="number">6</span>);</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; mset1.count(<span class="number">2</span>) &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i : mset1)  <span class="built_in">cout</span> &lt;&lt; i &lt;&lt; <span class="string">&quot; &quot;</span>; <span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="keyword">auto</span> it = mset1.find(<span class="number">3</span>);</span><br><span class="line">it++; <span class="built_in">cout</span> &lt;&lt; *it &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">it = mset1.find(<span class="number">0</span>);</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="built_in">std</span>::boolalpha &lt;&lt; (it == mset1.end()) &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">it = mset1.lower_bound(<span class="number">2</span>); <span class="built_in">cout</span> &lt;&lt; *it &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">it = mset1.upper_bound(<span class="number">2</span>); <span class="built_in">cout</span> &lt;&lt; *it &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="keyword">auto</span> it2 = mset1.equal_range(<span class="number">2</span>); <span class="built_in">cout</span> &lt;&lt; *it2.first &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; *it2.second &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; mset1.size() &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">it= mset1.find(<span class="number">2</span>);</span><br><span class="line">mset1.erase(it);<span class="comment">//删除一个</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i : mset1)  <span class="built_in">cout</span> &lt;&lt; i &lt;&lt; <span class="string">&quot; &quot;</span>; <span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">mset1.erase(<span class="number">2</span>);<span class="comment">//删除所有</span></span><br><span class="line">mset1.erase(<span class="number">100</span>);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i : mset1)  <span class="built_in">cout</span> &lt;&lt; i &lt;&lt; <span class="string">&quot; &quot;</span>; <span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">3</span><br><span class="line">2 2 2 3 4 5 6</span><br><span class="line">4</span><br><span class="line">true</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">2 3</span><br><span class="line">7</span><br><span class="line">2 2 3 4 5 6</span><br><span class="line">3 4 5 6</span><br></pre></td></tr></table></figure><h3 id="mapmultimap"><a class="markdownIt-Anchor" href="#mapmultimap"></a> map/multimap</h3><p>关联容器，不允许相同的key，存储的对象必须可排序。<br /><img src="https://lcg-pic-tencent-1258286866.cos.ap-chengdu.myqcloud.com/a%5Cb%5C20200817231906_f1a373cb31070bf14c7ea393cd36488e.png" alt="a\b\20200817231906_f1a373cb31070bf14c7ea393cd36488e.png" /></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt; <span class="class"><span class="keyword">class</span> <span class="title">Key</span>,                                     // 指定键（<span class="title">key</span>）的类型</span></span><br><span class="line"><span class="class">           <span class="keyword">class</span> <span class="title">T</span>,                                       // 指定值（<span class="title">value</span>）的类型</span></span><br><span class="line"><span class="class">           <span class="keyword">class</span> <span class="title">Compare</span> =</span> less&lt;Key&gt;,                     <span class="comment">// 指定排序规则</span></span><br><span class="line">           <span class="class"><span class="keyword">class</span> <span class="title">Alloc</span> =</span> allocator&lt;<span class="built_in">pair</span>&lt;<span class="keyword">const</span> Key,T&gt; &gt;    <span class="comment">// 指定分配器对象的类型</span></span><br><span class="line">           &gt; <span class="class"><span class="keyword">class</span> <span class="title">map</span>;</span></span><br></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">map</span>&lt;<span class="keyword">int</span>,<span class="keyword">char</span>&gt;mp1;</span><br><span class="line">mp1[<span class="number">0</span>] = <span class="number">0</span> + <span class="string">&#x27;0&#x27;</span>;<span class="comment">//可直接赋值</span></span><br><span class="line">mp1[<span class="number">0</span>] = <span class="number">0</span> + <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; mp1.count(<span class="number">0</span>) &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">5</span>; i &gt;= <span class="number">0</span>; --i) mp1.emplace(i, i + <span class="string">&#x27;0&#x27;</span>);<span class="comment">//直接构造</span></span><br><span class="line">mp1.insert(<span class="built_in">make_pair</span>(<span class="number">6</span>, <span class="number">6</span> + <span class="string">&#x27;0&#x27;</span>));</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">auto</span> i : mp1)<span class="built_in">cout</span> &lt;&lt; i.second &lt;&lt; <span class="string">&quot; &quot;</span>; <span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">1</span><br><span class="line">0 1 2 3 4 5 6</span><br></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">multimap</span>&lt;<span class="keyword">int</span>, <span class="keyword">char</span>&gt;mp1;</span><br><span class="line"><span class="comment">//mp1[0] = 0 + &#x27;0&#x27;;//不可直接赋值</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">5</span>; i &gt;= <span class="number">0</span>; --i) mp1.emplace(i, i + <span class="string">&#x27;0&#x27;</span>);<span class="comment">//直接构造</span></span><br><span class="line">mp1.insert(<span class="built_in">make_pair</span>(<span class="number">6</span>, <span class="number">6</span> + <span class="string">&#x27;0&#x27;</span>));</span><br><span class="line">mp1.insert(<span class="built_in">make_pair</span>(<span class="number">0</span>, <span class="number">0</span> + <span class="string">&#x27;0&#x27;</span>));<span class="comment">//重复的也会压进去</span></span><br><span class="line">mp1.insert(<span class="built_in">make_pair</span>(<span class="number">0</span>, <span class="number">7</span> + <span class="string">&#x27;0&#x27;</span>));</span><br><span class="line">mp1.insert(<span class="built_in">make_pair</span>(<span class="number">0</span>, <span class="number">8</span> + <span class="string">&#x27;0&#x27;</span>));</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; mp1.count(<span class="number">0</span>) &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">auto</span> i : mp1)<span class="built_in">cout</span> &lt;&lt; i.second &lt;&lt; <span class="string">&quot; &quot;</span>; <span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">auto</span> it = mp1.begin(); it != mp1.end(); ++it)<span class="built_in">cout</span> &lt;&lt; it-&gt;first &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; it-&gt;second &lt;&lt; <span class="built_in">endl</span>;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">4</span><br><span class="line">0 0 7 8 1 2 3 4 5 6</span><br><span class="line">0 0</span><br><span class="line">0 0</span><br><span class="line">0 7</span><br><span class="line">0 8</span><br><span class="line">1 1</span><br><span class="line">2 2</span><br><span class="line">3 3</span><br><span class="line">4 4</span><br><span class="line">5 5</span><br><span class="line">6 6</span><br></pre></td></tr></table></figure><h4 id="哈希表"><a class="markdownIt-Anchor" href="#哈希表"></a> 哈希表</h4><p><a href="http://c.biancheng.net/view/3437.html">哈希表（散列表）详解（包含哈希表处理冲突的方法）</a><br />哈希函数：f（）是一个函数，通过这个函数可以快速求出该关键字对应的的数据的哈希地址，称之为“哈希函数”<br />哈希冲突：对于哈希表而言，冲突只能尽可能地少，无法完全避免。<br />哈希地址：哈希地址只是表示在查找表中的存储位置，而不是实际的物理存储位置。<br /><strong>常用的哈希函数的构造方法有 6 种：</strong></p><ul><li>直接定址法：其哈希函数为<strong>一次函数</strong>，H（key）= key 或者 H（key）=a * key + b，其中 H（key）表示关键字为 key 对应的哈希地址，a 和 b 都为常数。</li><li>数字分析法 ：如果关键字由多位字符或者数字组成，就可以考虑抽取其中的 2 位或者多位作为该关键字对应的哈希地址，在取法上尽量<strong>选择变化较多</strong>的位，避免冲突发生。</li><li>平方取中法：关键字做平方操作，取中间得几位作为哈希地址。</li><li>折叠法</li><li>除留余数法：若已知整个哈希表的最大长度 m，可以取一个不大于 m 的数 p，然后对该关键字 key 做取余运算，即：H（key）= key % p，在此方法中，对于 p 的取值非常重要，由经验得知 p 可以为<strong>不大于 m 的质数或者不包含小于 20 的质因数的合数</strong>。</li><li>随机数法：是取关键字的一个(伪)随机函数值作为它的哈希地址，即：H（key）=random（key），此方法适用于关键字长度不等的情况。</li></ul><p><strong>处理冲突的方法</strong></p><ul><li>开放定址法 ： H（key）=（H（key）+ d）MOD m（其中 m 为哈希表的表长，d 为一个增量） 当得出的哈希地址产生冲突时，选取以下 3 种方法中的一种获取 d 的值，然后继续计算，直到计算出的哈希地址不在冲突为止，这 3 种方法为：<ul><li>线性探测法：d=1，2，3，…，m-1</li><li>二次探测法：d=12，-12，22，-22，32，…</li><li>伪随机数探测法：d=伪随机数</li></ul></li><li>再哈希法</li><li>链地址法</li><li>建立一个公共溢出区</li></ul><h4 id="unordered"><a class="markdownIt-Anchor" href="#unordered"></a> unordered</h4><ul><li>关联式容器的底层实现采用的树存储结构，更确切的说是红黑树结构；</li><li>无序容器的底层实现采用的是哈希表的存储结构。</li></ul><p>C++ STL 底层采用哈希表实现无序容器时，会将所有数据存储到一整块连续的内存空间中，并且当数据存储位置发生冲突时，解决方法选用的是“<code>链地址法</code>”（又称“开链法”）。</p><ul><li>无序容器内部存储的键值对是无序的，各键值对的存储位置取决于该键值对中的键，</li><li>和关联式容器相比，无序容器擅长通过指定键查找对应的值（平均时间复杂度为 O(1)）；但对于使用迭代器遍历容器中存储的元素，无序容器的执行效率则不如关联式容器。</li></ul><p><a href="https://blog.csdn.net/wusecaiyun/article/details/46723363">https://blog.csdn.net/wusecaiyun/article/details/46723363</a></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">map, set, multimap, and multiset</span><br><span class="line">上述四种容器采用红黑树实现，红黑树是平衡二叉树的一种。不同操作的时间复杂度近似为:</span><br><span class="line">插入: O(logN)</span><br><span class="line">查看:O(logN)</span><br><span class="line">删除:O(logN)</span><br><span class="line"></span><br><span class="line">hash_map, hash_set, hash_multimap, and hash_multiset</span><br><span class="line">上述四种容器采用哈希表实现，不同操作的时间复杂度为：</span><br><span class="line">插入:O(1)，最坏情况O(N)。</span><br><span class="line">查看:O(1)，最坏情况O(N)。</span><br><span class="line">删除:O(1)，最坏情况O(N)。</span><br><span class="line">记住，如果你采用合适的哈希函数，你可能永远不会看到最坏情况。但是记住这一点是有必要的。</span><br></pre></td></tr></table></figure><p><img src="https://lcg-pic-tencent-1258286866.cos.ap-chengdu.myqcloud.com/a%5Cb%5C20200819165151_1bfe30f9d8d06ff23242a5d7a892b7fb.png" alt="a\b\20200819165151_1bfe30f9d8d06ff23242a5d7a892b7fb.png" /><br /><img src="https://lcg-pic-tencent-1258286866.cos.ap-chengdu.myqcloud.com/a%5Cb%5C20200819165217_3da67063eb2b5c12c28fff080220bde0.png" alt="a\b\20200819165217_3da67063eb2b5c12c28fff080220bde0.png" /></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h3 id=&quot;参考&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#参考&quot;&gt;&lt;/a&gt; 参考&lt;/h3&gt;
&lt;p&gt;&lt;a href=&quot;http://www.cplusplus.com/reference/stl/&quot;&gt;http://www.cplusplus.c</summary>
      
    
    
    
    <category term="C/C++" scheme="https://www.liuchanggeng.xyz/categories/C-C/"/>
    
    
    <category term="学习笔记" scheme="https://www.liuchanggeng.xyz/tags/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>大量数据处理</title>
    <link href="https://www.liuchanggeng.xyz/2020/08/23/CPP-Notes/%E5%A4%A7%E9%87%8F%E6%95%B0%E6%8D%AE%E5%A4%84%E7%90%86/"/>
    <id>https://www.liuchanggeng.xyz/2020/08/23/CPP-Notes/%E5%A4%A7%E9%87%8F%E6%95%B0%E6%8D%AE%E5%A4%84%E7%90%86/</id>
    <published>2020-08-23T13:26:00.000Z</published>
    <updated>2020-11-16T09:10:53.407Z</updated>
    
    <content type="html"><![CDATA[<h3 id=""><a class="markdownIt-Anchor" href="#"></a> </h3><h4 id="bitmap"><a class="markdownIt-Anchor" href="#bitmap"></a> bitMap</h4><p>可以运用在快速查找、去重、排序、压缩数据等。</p><p>将整数n放置在第n个bit位，扫描后按左至右或右至左输入即为排好序的。<br /><a href="https://www.cnblogs.com/dyllove98/archive/2013/07/26/3217741.html">https://www.cnblogs.com/dyllove98/archive/2013/07/26/3217741.html</a><br /><a href="https://www.cnblogs.com/senlinyang/p/7885685.html">https://www.cnblogs.com/senlinyang/p/7885685.html</a><br />题目：一个10G的文件，里面全部是自然数，一行一个，乱序排列，对其排序。在32位机器上面完成，内存限制为 2G。</p><p>首先来分析一下题目，10G的文件，只有2G内存，显然，不可能一次性把数据放入内存中直接排序。那么，还有什么其他办法呢？遍寻资料，可以发现大致有两种解决方案：</p><p>1、把大文件分成多个小文件，分别排序，到最后合并成一个文件（我暂时还没搞懂这个方法，所以不会描述，有兴趣的看官可以自己去查一下）；</p><p>2、另外一种方法就是著名的bitmap算法了。<br /><a href="https://www.jianshu.com/p/bf9dbbc147ed">https://www.jianshu.com/p/bf9dbbc147ed</a></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//arr[n]的第m位置1</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">setBit</span><span class="params">(<span class="keyword">int</span> num,<span class="keyword">int</span> arr[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n = num / <span class="number">32</span>;</span><br><span class="line">    <span class="keyword">int</span> m = num % <span class="number">32</span>;</span><br><span class="line">    arr[n] += (<span class="number">1</span> &lt;&lt; m);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//地位至高位打印</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">printBitMap</span><span class="params">(<span class="keyword">int</span> arr[],<span class="keyword">int</span> len)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i&lt;len; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> n = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> ii = <span class="number">0</span>; ii &lt; <span class="number">32</span>; ++ii)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> ((arr[i] &amp; n) == n)<span class="comment">//这里时==n，不是==1</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="built_in">cout</span> &lt;&lt; i * <span class="number">32</span> + ii &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            n &lt;&lt;= <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">clr</span><span class="params">(<span class="keyword">int</span> arr[], <span class="keyword">int</span> len)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len; ++i)</span><br><span class="line">        arr[i] = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> arr[<span class="number">100</span>];</span><br><span class="line">    <span class="keyword">int</span> arr2[<span class="number">10</span>] = &#123; <span class="number">100</span>,<span class="number">800</span>,<span class="number">22</span>,<span class="number">314</span>,<span class="number">21</span>,<span class="number">44</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">3</span>,<span class="number">2</span> &#125;;</span><br><span class="line">    clr(arr,<span class="number">100</span>);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        setBit(arr2[i], arr);</span><br><span class="line">    &#125;</span><br><span class="line">    printBitMap(arr, <span class="number">100</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">0</span><br><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">44</span><br><span class="line">100</span><br><span class="line">314</span><br><span class="line">800</span><br></pre></td></tr></table></figure><h4 id="bitset"><a class="markdownIt-Anchor" href="#bitset"></a> bitset</h4><p><a href="https://www.cnblogs.com/RabbitHu/p/bitset.html">https://www.cnblogs.com/RabbitHu/p/bitset.html</a><br /><a href="http://www.cplusplus.com/reference/bitset/bitset/">http://www.cplusplus.com/reference/bitset/bitset/</a><br />C++封装的bitMap，是模板类</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bitset&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function"><span class="built_in">bitset</span>&lt;32&gt; <span class="title">bs</span><span class="params">(<span class="number">3</span>)</span></span>;<span class="comment">//相当于...0011</span></span><br><span class="line">   <span class="comment">// bs.set(3);</span></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; bs.count() &lt;&lt; <span class="built_in">endl</span>;<span class="comment">//3</span></span><br><span class="line">    bs.<span class="built_in">set</span>(<span class="number">4</span>);<span class="comment">//第5位置1</span></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; bs.size() &lt;&lt; <span class="built_in">endl</span>;<span class="comment">//32</span></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; bs.to_string() &lt;&lt; <span class="built_in">endl</span>;<span class="comment">//00000000000000000000000000010011</span></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; bs.to_ullong() &lt;&lt; <span class="built_in">endl</span>;<span class="comment">//19</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bitset&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">bitset</span>&lt;1000&gt; bs;</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; arr = &#123; <span class="number">9</span>,<span class="number">2</span>,<span class="number">4</span>,<span class="number">12</span>,<span class="number">100</span>,<span class="number">900</span>,<span class="number">788</span>,<span class="number">20</span> &#125;;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">auto</span> a : arr) bs.<span class="built_in">set</span>(a);</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt;<span class="string">&quot;count: &quot;</span> &lt;&lt;bs.count() &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; bs.size(); i++)</span><br><span class="line"><span class="keyword">if</span> (bs[i] == <span class="number">1</span>)</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; i &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">count: 8</span><br><span class="line">2 4 9 12 20 100 788 900</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h3 id=&quot;&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#&quot;&gt;&lt;/a&gt; &lt;/h3&gt;
&lt;h4 id=&quot;bitmap&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#bitmap&quot;&gt;&lt;/a&gt; bitMap&lt;/h4&gt;
&lt;p&gt;可</summary>
      
    
    
    
    <category term="C/C++" scheme="https://www.liuchanggeng.xyz/categories/C-C/"/>
    
    
    <category term="学习笔记" scheme="https://www.liuchanggeng.xyz/tags/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>STL-迭代器</title>
    <link href="https://www.liuchanggeng.xyz/2020/08/20/CPP-Notes/%E8%BF%AD%E4%BB%A3%E5%99%A8/"/>
    <id>https://www.liuchanggeng.xyz/2020/08/20/CPP-Notes/%E8%BF%AD%E4%BB%A3%E5%99%A8/</id>
    <published>2020-08-20T09:36:00.000Z</published>
    <updated>2020-11-16T09:07:40.898Z</updated>
    
    <content type="html"><![CDATA[<h3 id="迭代器"><a class="markdownIt-Anchor" href="#迭代器"></a> 迭代器</h3><p><img src="https://lcg-pic-tencent-1258286866.cos.ap-chengdu.myqcloud.com/a%5Cb%5C20200818003959_b660a9345b3d4954399896e020231cf8.png" alt="a\b\20200818003959_b660a9345b3d4954399896e020231cf8.png" /></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h3 id=&quot;迭代器&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#迭代器&quot;&gt;&lt;/a&gt; 迭代器&lt;/h3&gt;
&lt;p&gt;&lt;img src=&quot;https://lcg-pic-tencent-1258286866.cos.ap-chengdu.myqcloud.</summary>
      
    
    
    
    <category term="C/C++" scheme="https://www.liuchanggeng.xyz/categories/C-C/"/>
    
    
    <category term="学习笔记" scheme="https://www.liuchanggeng.xyz/tags/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>STL-algorithm</title>
    <link href="https://www.liuchanggeng.xyz/2020/08/19/CPP-Notes/algorithm/"/>
    <id>https://www.liuchanggeng.xyz/2020/08/19/CPP-Notes/algorithm/</id>
    <published>2020-08-19T09:36:00.000Z</published>
    <updated>2020-11-16T09:08:09.789Z</updated>
    
    <content type="html"><![CDATA[<h3 id="stl-algorithm"><a class="markdownIt-Anchor" href="#stl-algorithm"></a> STL algorithm</h3><p>泛型算法本身不会执行容器的操作，他们只会运行迭代器之上。永远不会添加和删除元素。不是说容器经过算法后容器大小不变，而是算法会通过使用迭代器而控制容器，而不是直接控制容器。如插入器(inserter)</p><h4 id="remove"><a class="markdownIt-Anchor" href="#remove"></a> remove</h4><p>移除指定元素</p><h4 id="remove_if"><a class="markdownIt-Anchor" href="#remove_if"></a> remove_if</h4><p><a href="https://www.cnblogs.com/zhangdongsheng/p/8590221.html">c++ remove_if</a><br />remove_if()并不会实际移除序列[start, end)中的元素; 如果在一个容器上应用remove_if(), 容器的长度并不会改变(remove_if()不可能仅通过迭代器改变容器的属性), 所有的元素都还在容器里面. 实际做法是, remove_if()将所有应该移除的元素都移动到了容器尾部并返回一个分界的迭代器. 移除的所有元素仍然可以通过返回的迭代器访问到. 为了实际移除元素, 你必须对容器自行调用erase()以擦除需要移除的元素.</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">container.erase(remove_if(container.begin(), container.end(), pred), container.end());</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h3 id=&quot;stl-algorithm&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#stl-algorithm&quot;&gt;&lt;/a&gt; STL algorithm&lt;/h3&gt;
&lt;p&gt;泛型算法本身不会执行容器的操作，他们只会运行迭代器之上。永远不会添加和删除元素</summary>
      
    
    
    
    <category term="C/C++" scheme="https://www.liuchanggeng.xyz/categories/C-C/"/>
    
    
    <category term="学习笔记" scheme="https://www.liuchanggeng.xyz/tags/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>STL-适配器(adaptor)</title>
    <link href="https://www.liuchanggeng.xyz/2020/08/19/CPP-Notes/%E9%80%82%E9%85%8D%E5%99%A8/"/>
    <id>https://www.liuchanggeng.xyz/2020/08/19/CPP-Notes/%E9%80%82%E9%85%8D%E5%99%A8/</id>
    <published>2020-08-19T03:13:00.000Z</published>
    <updated>2020-11-16T09:10:03.749Z</updated>
    
    <content type="html"><![CDATA[<h3 id="适配器adaptor"><a class="markdownIt-Anchor" href="#适配器adaptor"></a> 适配器(adaptor)</h3><p>本质上，适配器是一种<code>机制</code>，能使某种事物的行为看起来像另外一种事物一样。一个容器适配器接受一种已有的容器类型，使其行为看起来像一种不同的类型(stack接受一个除array和forward_list外的顺序容器)。<br />通常适配器内部不怎么操作，而总是调用底层操作。<br />标准库中的顺序容器适配器</p><ul><li>stack</li><li>queue</li><li>priority_queue</li></ul><p>每个适配器有两个构造函数：</p><ul><li>默认构造函数：构造空对象</li><li>拷贝构造函数:可接受适配的容器</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">deque</span>&lt;<span class="keyword">int</span>&gt; deq;</span><br><span class="line"><span class="function"><span class="built_in">stack</span>&lt;<span class="keyword">int</span>&gt; <span class="title">stk</span><span class="params">(deq)</span></span>;<span class="comment">//从deq中拷贝元素到stk</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>适配器都有添加和删除和访问尾元素的能力，所以不能构造在array上，同理，forward_list也不能用来构造适配器。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h3 id=&quot;适配器adaptor&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#适配器adaptor&quot;&gt;&lt;/a&gt; 适配器(adaptor)&lt;/h3&gt;
&lt;p&gt;本质上，适配器是一种&lt;code&gt;机制&lt;/code&gt;，能使某种事物的行为看起来像另外一种事物一</summary>
      
    
    
    
    <category term="C/C++" scheme="https://www.liuchanggeng.xyz/categories/C-C/"/>
    
    
    <category term="学习笔记" scheme="https://www.liuchanggeng.xyz/tags/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>结构体内长度为0的数组</title>
    <link href="https://www.liuchanggeng.xyz/2020/08/05/CPP-Notes/%E7%BB%93%E6%9E%84%E4%BD%93%E9%95%BF%E5%BA%A6%E4%B8%BA0%E7%9A%84%E6%95%B0%E7%BB%84/"/>
    <id>https://www.liuchanggeng.xyz/2020/08/05/CPP-Notes/%E7%BB%93%E6%9E%84%E4%BD%93%E9%95%BF%E5%BA%A6%E4%B8%BA0%E7%9A%84%E6%95%B0%E7%BB%84/</id>
    <published>2020-08-04T17:34:00.000Z</published>
    <updated>2020-11-16T09:13:03.483Z</updated>
    
    <content type="html"><![CDATA[<h3 id="结构体内长度为0的数组"><a class="markdownIt-Anchor" href="#结构体内长度为0的数组"></a> 结构体内长度为0的数组</h3><h4 id="参考资料"><a class="markdownIt-Anchor" href="#参考资料"></a> 参考资料</h4><ul><li><a href="https://blog.csdn.net/gatieme/article/details/64131322">C语言0长度数组(可变数组/柔性数组)详解</a></li></ul><p>*<a href="https://blog.csdn.net/songjinn/article/details/16982349">结构体中数组下标为0</a><br />思考一种场景：需要一个结构体，结构体中的需要一个缓冲区，用于接收不定长数据。则最可能想到的就是两种解决方案：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//1.开辟定长大缓冲区，用定长数组</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MaxLength 1024</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">S1</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">int</span> len;<span class="comment">//实际数据长度len&lt;MaxLength</span></span><br><span class="line"><span class="keyword">int</span> data[MaxLength];</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> data[<span class="number">10</span>] = &#123; <span class="number">0</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>,<span class="number">9</span> &#125;;</span><br><span class="line">    <span class="keyword">int</span> len = <span class="number">10</span>;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">S1</span>* <span class="title">pS1</span>;</span></span><br><span class="line">    <span class="keyword">int</span> data[<span class="number">10</span>] = &#123; <span class="number">0</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>,<span class="number">9</span> &#125;;</span><br><span class="line">    <span class="keyword">int</span> len = <span class="number">10</span>;</span><br><span class="line">    <span class="keyword">if</span> (pS1 = (struct S1*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(S1)))</span><br><span class="line">    &#123;</span><br><span class="line">    pS1-&gt;len = len;</span><br><span class="line">    <span class="built_in">memcpy</span>(pS1-&gt;data, data,<span class="keyword">sizeof</span>(pS1-&gt;data[<span class="number">0</span>])*len);</span><br><span class="line">    &#125;   </span><br><span class="line">    <span class="built_in">free</span>(pS1);</span><br><span class="line">    pS1 = <span class="literal">nullptr</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//结构体里使用指针做缓冲区</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">S2</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">int</span> len;</span><br><span class="line">    <span class="keyword">int</span>* data;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> data[<span class="number">10</span>] = &#123; <span class="number">0</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>,<span class="number">9</span> &#125;;</span><br><span class="line"><span class="keyword">int</span> len = <span class="number">10</span>;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">S2</span>* <span class="title">pS2</span>;</span></span><br><span class="line">    <span class="keyword">if</span> (pS2 = (struct S2*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(S2)))<span class="comment">//一步</span></span><br><span class="line">    &#123;</span><br><span class="line">    <span class="keyword">if</span> (pS2-&gt;data = (<span class="keyword">int</span>*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="keyword">int</span>) * len))<span class="comment">//两部</span></span><br><span class="line">    &#123;</span><br><span class="line">            <span class="comment">//两次分配的内存是不连续的, 需要分别对其进行管理</span></span><br><span class="line">    <span class="built_in">memcpy</span>(pS2-&gt;data, data, <span class="keyword">sizeof</span>(<span class="keyword">int</span>) * len);</span><br><span class="line">    &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">free</span>(pS2-&gt;data);</span><br><span class="line">    <span class="built_in">free</span>(pS2);</span><br><span class="line">    pS2 = <span class="literal">nullptr</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><p>使用指针结果作为缓冲区, 只多使用了一个指针大小的空间, 无需使用 一定 长度的数组, 不会造成空间的大量浪费.</p></li><li><p>但那是开辟空间时, 需要额外开辟数据域的空间, 释放时候也需要显示释放数据域的空间, 但是实际使用过程中, 往往在函数中开辟空间, 然后返回给使用者指向 struct point_buffer 的指针, 这时候我们并不能假定使用者了解我们开辟的细节, 并按照约定的操作释放空间, 因此使用起来多有不便, 甚至造成内存泄漏。</p></li></ul><p>定长数组使用方便, 但是却浪费空间, 指针形式只多使用了一个指针的空间, 不会造成大量空间分浪费, 但是使用起来需要多次分配, 多次释放, 那么有没有一种实现方式能够既不浪费空间, 又使用方便的呢?</p><p>GNU C 的0长度数组, 也叫变长数组, 柔性数组就是这样一个扩展. 对于0长数组的这个特点，很容易构造出变成结构体，如缓冲区，数据包等等：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">S3</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">int</span> len;</span><br><span class="line">    <span class="keyword">int</span> data[<span class="number">0</span>];</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> data[<span class="number">10</span>] = &#123; <span class="number">0</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>,<span class="number">9</span> &#125;;</span><br><span class="line">    <span class="keyword">int</span> len = <span class="number">10</span>;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">S3</span>* <span class="title">pS3</span>;</span></span><br><span class="line">    <span class="keyword">if</span> (pS3 = (struct S3*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(struct S3) + sizeo  (<span class="keyword">int</span>) * len))<span class="comment">//len这里不分配也可以memcpy,但free会出问题</span></span><br><span class="line">    &#123;</span><br><span class="line">    <span class="built_in">memcpy</span>(pS3-&gt;data, data, <span class="keyword">sizeof</span>(<span class="keyword">int</span>) * len);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">free</span>(pS3);</span><br><span class="line">    pS3 = <span class="literal">nullptr</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h3 id=&quot;结构体内长度为0的数组&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#结构体内长度为0的数组&quot;&gt;&lt;/a&gt; 结构体内长度为0的数组&lt;/h3&gt;
&lt;h4 id=&quot;参考资料&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=</summary>
      
    
    
    
    <category term="C/C++" scheme="https://www.liuchanggeng.xyz/categories/C-C/"/>
    
    
    <category term="学习笔记" scheme="https://www.liuchanggeng.xyz/tags/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>函数指针</title>
    <link href="https://www.liuchanggeng.xyz/2020/07/28/CPP-Notes/%E5%87%BD%E6%95%B0%E6%8C%87%E9%92%88/"/>
    <id>https://www.liuchanggeng.xyz/2020/07/28/CPP-Notes/%E5%87%BD%E6%95%B0%E6%8C%87%E9%92%88/</id>
    <published>2020-07-28T02:04:00.000Z</published>
    <updated>2020-11-16T09:12:21.789Z</updated>
    
    <content type="html"><![CDATA[<h3 id="函数指针"><a class="markdownIt-Anchor" href="#函数指针"></a> 函数指针</h3><h4 id="参考资料"><a class="markdownIt-Anchor" href="#参考资料"></a> 参考资料</h4><p><a href="https://www.cnblogs.com/shenlian/archive/2011/05/21/2053149.html">typedef int (*MYFUN)(int, int)</a></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> once</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span>  FUNC_PTR_H</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> FUNC_PTR_H</span></span><br><span class="line"><span class="function"><span class="keyword">typedef</span> <span class="title">int</span> <span class="params">(*pfint)</span><span class="params">(<span class="keyword">int</span>)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">func1</span><span class="params">(<span class="keyword">int</span> a)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">func2</span><span class="params">(<span class="keyword">int</span> a)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span>* <span class="title">func3</span><span class="params">(<span class="keyword">int</span> &amp;a)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span> <span class="comment">// ! FUNC_PTR_H</span></span></span><br><span class="line"></span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;func_ptr.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">func1</span><span class="params">(<span class="keyword">int</span> a)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;func1:  &quot;</span> &lt;&lt; a &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;&amp;func1:  &quot;</span> &lt;&lt; &amp;func1 &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="keyword">return</span> a;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">func2</span><span class="params">(<span class="keyword">int</span> a)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;func2:  &quot;</span> &lt;&lt; a &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="keyword">return</span> a;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span>* <span class="title">func3</span><span class="params">(<span class="keyword">int</span> &amp;a)</span><span class="comment">//需要传引用，如果传值，返回的是局部变量的地址</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;func3: &quot;</span> &lt;&lt; a &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="keyword">return</span> &amp;a;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;func_ptr.h&quot;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    func1(<span class="number">1</span>);</span><br><span class="line">    func2(<span class="number">2</span>);</span><br><span class="line">    <span class="keyword">int</span> (*pfunc)(<span class="keyword">int</span>) = &amp;func1;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; pfunc &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    (*pfunc)(<span class="number">3</span>);</span><br><span class="line">    pfunc = func2;<span class="comment">//函数名被使用时总是由编译器转化为函数指针</span></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; pfunc &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    (*pfunc)(<span class="number">4</span>);</span><br><span class="line">    pfunc = &amp;func2;</span><br><span class="line">    (*pfunc)(<span class="number">5</span>);</span><br><span class="line">    pfunc(<span class="number">6</span>);<span class="comment">//间接访问非必需，因为编译器需要的是一个函数指针</span></span><br><span class="line">    pfint pfint1;</span><br><span class="line">    pfint1 = func1;</span><br><span class="line">    pfint1(<span class="number">2</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">int</span> (*funcArr[<span class="number">2</span>])(<span class="keyword">int</span>);</span><br><span class="line">    funcArr[<span class="number">0</span>] = func1;</span><br><span class="line">    funcArr[<span class="number">1</span>] = func2;</span><br><span class="line">    funcArr[<span class="number">0</span>](<span class="number">1</span>);</span><br><span class="line">    funcArr[<span class="number">1</span>](<span class="number">2</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以new出来函数指针吗?没找到有这么写的。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h3 id=&quot;函数指针&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#函数指针&quot;&gt;&lt;/a&gt; 函数指针&lt;/h3&gt;
&lt;h4 id=&quot;参考资料&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#参考资料&quot;&gt;&lt;/a&gt; 参考资料&lt;/h4</summary>
      
    
    
    
    <category term="C/C++" scheme="https://www.liuchanggeng.xyz/categories/C-C/"/>
    
    
    <category term="学习笔记" scheme="https://www.liuchanggeng.xyz/tags/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
</feed>
